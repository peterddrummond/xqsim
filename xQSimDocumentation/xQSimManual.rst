==================
xQSim Manual: v2.0
==================

:Author: Peter D. Drummond, Alexander S. Dellios

.. role:: raw-latex(raw)
   :format: latex
..

Introduction
============

Large, network based experiments in quantum optics are becoming
increasingly common, pushing the development of networks to ever large
sizes. These optical linear networks have a variety of applications such
as quantum computers implementing a type of random-number generation
:raw-latex:`\cite{Aaronson2011,AaronsonArkhipov2013LV,Aaronson:2014,Hamilton2017PhysRevLett.119.170501,quesada2018gaussian,kruse2019detailed}`
and large scale interferometers producing output measurements below the
shot noise limit :raw-latex:`\cite{Motes2015_PRL114,Su2017Multiphoton}`.

Many implementations use nonclassical inputs
:raw-latex:`\cite{Reid1986violations}` such as squeezed states or number
states. These are not mathematically representable as a classical,
positive, non-singular Glauber-Sudarshan phase-space distribution
:raw-latex:`\cite{Glauber_1963_P-Rep,Sudarshan_1963_P-Rep}`.

Recently, large networks employed as quantum computers have been used to
claim quantum computational advantage
:raw-latex:`\cite{arute2019quantum,zhong2020quantum,Zhong2021Phase,madsenQuantumComputationalAdvantage2022}`.
This leads to a theoretical challenge: how does one check hardware
operation? Are the random numbers generated correctly? Do they follow
the expected probability distribution?

Traditional number-state validation methods are only practical for small
scale networks, since they use an exponentially large basis set. This
rules out direct calculations, due to the finite size, computational
time and precision of a digital computer. Although more feasible, even
Monte-Carlo methods take an exponentially long time digitally
:raw-latex:`\cite{bulmerBoundaryQuantumAdvantage2022a}`.

Other methods utilize marginal probabilities of the expected
distribution, which are calculable
:raw-latex:`\cite{villalonga2021efficient,ohSpoofingCrossEntropy2022a}`.
Although scalable, such methods cannot verify higher-order correlations
generated in the network. Therefore, these methods can only validate
part of a larger picture.

For Gaussian boson sampling with linear networks, other methods using
quantum phase-space exist. These do allow comparisons of theory and
experiment for large, nonclassical networks, simulating all possible
correlations generated by an experiment. A computational implementation
is necessary, however. xQSim - meaning e\ **x**\ tensible **Q**\ uantum
**Sim**\ ulations using phase-space representations - is a software
package that does this.

While xQSim is able to compare theoretical predictions with experimental
data, it cannot generate a direct random output of photon counts. This
is the task implemented by experiments
:raw-latex:`\cite{zhong2020quantum,Zhong2021Phase,madsenQuantumComputationalAdvantage2022}`
and some validation methods :raw-latex:`\cite{villalonga2021efficient}`.
However, there is extensive theory suggesting that such brute-force
computations are #P hard
:raw-latex:`\cite{Aaronson2011,AaronsonArkhipov2013LV,Aaronson:2014,lund2014boson,Hamilton2017PhysRevLett.119.170501,quesada2018gaussian,kruse2019detailed}`,
and therefore our code implements a completely different approach.

To do this, we employ three phase-space simulation methods: the positive
P-distribution :raw-latex:`\cite{Drummond_generalizedP1980}`
(:math:`method=1`), the Wigner distribution
:raw-latex:`\cite{Wigner_1932}` (:math:`method=2`), provided it has a
positive distribution for the corresponding input state, and the Husimi
Q-function :raw-latex:`\cite{Husimi1940}` (:math:`method=3`).

The present code distribution can simulate multidimensional photon
probabilities, photon number correlations and quadrature moments for a
variety of inputs, networks and output measurements. It uses sampling
and binning to obtain computable results, giving error-bars comparable
to those of the experimental measurements. In addition to simulating
Gaussian quantum inputs, admixtures of thermal noise can be included to
model phase decoherence in the input states.

Saturating or click detectors require the use of :math:`method=1`. This
is also preferred for intensity correlations, due to the exponentially
lower sampling error obtained. Quadrature measurements are best
simulated with :math:`method=2`. However, intensity correlation and
quadrature probabilities can be simulated using all methods.

The code also generates arbitrarily binned moments. These are vital for
large-scale comparisons with data, due to the exponential sparsity of
the full probability distributions. It can also extract experimental
moments from available public datasets, which depends on the available
data and the encoding employed.

The programs provided are written in Matlab, which is a proprietary
language of The Mathworks Inc. It is fully compatible with Octave, which
is a free public domain clone of Matlab. Parallel features are only
available in Matlab currently, and require the parallel toolbox to give
large speed improvements on multicore computers.

A GPU/Python version exists :raw-latex:`\cite{Opanchuk2021}`, for GPU
enabled supercomputers. While this does not implement all the features
of the Matlab version, it is faster, with up to :math:`16,000` qubits
demonstrated. For user’s familiar with the original xQSim version
:raw-latex:`\cite{Drummond2022simulating}`, four new features have been
introduced:

-  Random permutations: Users can now randomly permute output binary
   patterns, changing the order of the binning for multi-dimensional
   simulations. This allows an exponential number of possible
   experimental comparisons to occur, with each permutation simulating a
   different correlation.

-  New data: Experimental data and extraction code corresponding to the
   larger experiment from Ref. :raw-latex:`\cite{Zhong2021Phase}`.

-  Z-score, or Z-statistic, tests: An additional statistical test which
   allows users to determine how randomly distributed each output
   pattern is.

-  xGraph3 compatibility: This version is fully compatible with xGraph3,
   a companion batch graphics program that includes extensive graphical
   and statistical comparisons.

Sections `[sec:Theoretical-background] <#sec:Theoretical-background>`__
through `[sec:Numerical-methods] <#sec:Numerical-methods>`__ outline all
the necessary background theory implemented in xQSim. Additional
theoretical details can also be found in Refs.
:raw-latex:`\cite{drummond2020initial,Dellios2021,Drummond2022simulating,dellios2022validation}`.
A description of the main simulation code *xQSim* is given in section
`[sec:xQSim-operation] <#sec:xQSim-operation>`__ whilst descriptions of
observables, comparison functions used for testing and experimental data
are presented in sections
`[sec:Observations-and-comparisons] <#sec:Observations-and-comparisons>`__
and `[sec:Experimental-data] <#sec:Experimental-data>`__.

Finally, numerous examples of various input states and output
distributions are presented in section.
`[sec:Examples] <#sec:Examples>`__, with a general reference to xQSim
functions and parameters provided in section.
`[sec:xqSIM-reference] <#sec:xqSIM-reference>`__.

Theoretical background
======================

This section provides a comprehensive theoretical background to the
general theory of linear networks, including input inputs to the
network, detection mechanisms and observable correlations.

Linear photonic networks
------------------------

The numerical code solves for output observables obtained after a linear
transformation of a multi-mode quantum input state
:math:`\hat{\rho}^{(\text{in})}`. The mode transformation is generated
by a linear photonic network of generalized beam-splitters and phase
delays. This acts as an :math:`M`-mode interferometer such that output
modes are linear combinations of each input mode.

Without losses, the network itself is defined by an :math:`M\times M`
unitary matrix :math:`\boldsymbol{U}`. Physically, this corresponds to
the interference of input photons that generates large amounts of
entanglement due to the exponential number of paths available to
photons.

In the ideal, lossless case, one has:

.. math:: \hat{a}_{i}^{(\text{out})}=\sum_{j=1}^{M}U_{ij}\hat{a}_{j}^{(\text{in})},\label{eq:linear_combo}

where :math:`\hat{a}_{i}^{(\text{in})}` and
:math:`\hat{a}_{j}^{(\text{out})}` are the input and output annihilation
operators for modes :math:`i`, :math:`j` respectively.

Practically, losses in the network are commonplace, thus causing the
experimental transmission matrix to be non-unitary. Therefore, lossy
networks are denoted by the transmission matrix :math:`\boldsymbol{T}`.
Not every input channel needs to have an input. In these cases,
:math:`N\subset M` represents the number of input modes, thus changing
the unitary to an :math:`N\times M` transmission matrix.

These give a different transformation law, where:

.. math:: \hat{a}_{i}^{(\text{out})}=\sum_{j=1}^{N}T_{ij}\hat{a}_{j}^{(\text{in})}+\sum_{j=1}^{M}B_{ij}\hat{b}_{j}^{(\text{in})},\label{eq:linear_combo-1}

Here, the :math:`M` operators :math:`\hat{b}_{i}^{(\text{in})}`\ are
noise operators. These are necessary to conserve the operator
commutation relations. They comprise inputs from the reservoirs that
cause losses, as well as the :math:`M-N` vacuum inputs at unused ports.
They are independent commuting operators, whose reservoirs are all in a
vacuum state.

Due to the need to conserve commutators, we know that for both inputs
and outputs:

.. math::

   \begin{aligned}
   \left[\hat{a}_{i},\hat{a}_{j}\right] & =0\nonumber \\
   \left[\hat{a}_{i},\hat{a}_{j}^{\dagger}\right] & =\delta_{ij}.\label{eq:bose_comm_rel}
   \end{aligned}

Applying this to the outputs, considering a vacuum state input, and
taking expectation values, gives

.. math::

   \begin{aligned}
   \delta_{ij} & =\left\langle \left[\hat{a}_{i}^{(\text{out})},\hat{a}_{j}^{\dagger(\text{out})}\right]\right\rangle \nonumber \\
    & =\sum_{k}\left(T_{ik}T_{jk}^{*}+B_{ik}B_{jk}^{*}\right).
   \end{aligned}

Next, we can define a new :math:`M\times M` matrix

.. math:: \bm{D}=\bm{B}\bm{B}^{\dagger}=\bm{I}-\bm{T}\bm{T}^{\dagger}.

This is hermitian, since :math:`\bm{D}^{\dagger}=\bm{D}`, and so has a
diagonal representation as
:math:`D=\tilde{U}\lambda^{2}\tilde{U}^{\dagger}`, for some unitary
matrix :math:`\tilde{U}`. We assume that the transmission matrix
:math:`\bm{T}` is lossy, so that :math:`\bm{D}` is positive definite and
:math:`\lambda` is real, representing absorption rather than gain.

Quantum input states
--------------------

The input state is defined in a number of ways depending on the desired
distribution one wishes to sample from. If each input mode is
independent, :math:`\hat{\rho}^{(\text{in})}` is a product of input
states.

To sample from the permanent, inputs are single photon Fock states such
that

.. math:: \hat{\rho}^{(\text{in})}=\prod_{j=1}^{M}\left|1\right\rangle _{j}\left\langle 1\right|_{j},

where
:math:`\left|1\right\rangle _{j}=a_{j}^{\dagger}\left|0\right\rangle`.

To sample from the Hafnian or Torontonian, the input is a product of
single-mode pure squeezed vacuum states

.. math:: \hat{\rho}^{(\text{in})}=\prod_{j=1}^{M}\left|r_{j}\right\rangle \left\langle r_{j}\right|,

where :math:`\boldsymbol{r}=[r_{1},\dots,r_{M}]` is the squeezing vector
and

.. math::

   \begin{aligned}
   \left|r_{j}\right\rangle  & =\hat{S}(r_{j})\left|0\right\rangle \nonumber \\
    & =\exp\left(r_{j}\frac{(a_{j}^{\dagger})^{2}}{2}-r_{j}\frac{\hat{a}_{j}^{2}}{2}\right)\left|0\right\rangle ,\label{eq:squeezed_state_exp}
   \end{aligned}

is the squeezed vacuum state where we have assumed the squeezed phase is
zero.

Currently, xQSim can only generate input squeezed states and thermal
states as outlined below. Other inputs are possible, since the positive
P-representation and Q-representation are complete, positive
representations, and can be added through user customization.

Pure squeezed states
~~~~~~~~~~~~~~~~~~~~

For a single-mode, squeezed vacuum states are generated by applying the
squeezing operator :math:`\hat{S}(r)` onto a vacuum state. As is clear
from the operator definition
Eq.(`[eq:squeezed_state_exp] <#eq:squeezed_state_exp>`__), where we drop
the :math:`j` subscript for the single-mode case, squeezed vacuum states
always generate even numbers of photons.

The mean photon number
:math:`\bar{n}=\left\langle \hat{a}^{\dagger}\hat{a}\right\rangle` and
coherence :math:`m=\left\langle \left(\hat{a}\right)^{2}\right\rangle`
can be derived using the relations

.. math::

   \begin{aligned}
   \hat{S}^{\dagger}(r)\hat{a}\hat{S}(r) & =\hat{a}\cosh(r)-\hat{a}^{\dagger}\sinh(r)\nonumber \\
   \hat{S}^{\dagger}(r)\hat{a}^{\dagger}\hat{S}(r) & =\hat{a}^{\dagger}\cosh(r)-\hat{a}\sinh(r),
   \end{aligned}

where the mean photon number is

.. math::

   \begin{aligned}
   \bar{n} & =\left\langle \hat{a}^{\dagger}\hat{a}\right\rangle \nonumber \\
    & =\left\langle r\right|\hat{a}^{\dagger}\hat{a}\left|r\right\rangle \nonumber \\
    & =\left\langle 0\right|\hat{S}^{\dagger}(r)\hat{a}^{\dagger}\hat{a}\hat{S}(r)\left|0\right\rangle \nonumber \\
    & =\sinh^{2}(r),
   \end{aligned}

whilst the coherence is

.. math::

   \begin{aligned}
   m & =\left\langle \left(\hat{a}\right)^{2}\right\rangle \nonumber \\
    & =\left\langle r\right|\hat{a}\hat{a}\left|r\right\rangle \nonumber \\
    & =\left\langle 0\right|\hat{S}^{\dagger}(r)\hat{a}\hat{a}\hat{S}(r)\left|0\right\rangle \nonumber \\
    & =\sinh(r)\cosh(r).
   \end{aligned}

For pure squeezed states, the coherence and photon number are related
via :math:`m^{2}-\bar{n}=\bar{n}^{2}`.

The superposition of only even Fock states becomes clearer when
expanding the squeezed state in terms of Fock states as

.. math:: \left|r\right\rangle =\frac{1}{\sqrt{\cosh(r)}}\sum_{n=0}^{\infty}\frac{\sqrt{(2n)!}}{2^{n}n!}\tanh^{n}(r)\left|2n\right\rangle ,\label{eq:Fock state_exp}

where :math:`n=0,1,2,\dots` is the number of photons. From the above
Fock state expansion the photon number distribution for the squeezed
vacuum state is

.. math::

   \begin{aligned}
   P_{2n} & =\frac{1}{\cosh(r)}\frac{(2n)!}{(n!)^{2n}2^{2n}}(\tanh(r))^{2n},\nonumber \\
   P_{2n+1} & =0,
   \end{aligned}

with variance
:math:`\sigma_{n}^{2}=2\bar{n}(\bar{n}+1)=\bar{n}(1+\cosh(2r_{j}))`.

Squeezed states are minimum uncertainty states and are therefore defined
entirely by their quadrature variances. Using the quadrature operators

.. math::

   \begin{aligned}
   \hat{x} & =\hat{a}+\hat{a}^{\dagger}\nonumber \\
   \hat{y} & =-i\left(\hat{a}-\hat{a}^{\dagger}\right),
   \end{aligned}

which obey the commutation relation
:math:`\left[\hat{x}_{j},\hat{y}_{k}\right]=2i\delta_{jk}`, the normally
ordered :math:`x`-quadrature variance is obtained as

.. math::

   \begin{aligned}
   \left\langle :(\Delta\hat{x})^{2}:\right\rangle  & =\left\langle \hat{x}^{2}\right\rangle \nonumber \\
    & =2(n+m)\nonumber \\
    & =e^{2r}-1,\label{eq:x-quad}
   \end{aligned}

whilst the normally ordered :math:`y`-quadrature variance is

.. math::

   \begin{aligned}
   \left\langle :(\Delta\hat{y})^{2}:\right\rangle  & =\left\langle \hat{y}^{2}\right\rangle \nonumber \\
    & =2(n-m)\nonumber \\
    & =e^{-2r}-1.\label{eq:y-quad}
   \end{aligned}

All the results derived here are also valid for multiple modes, denoted
by the subscript :math:`j`, given each mode is independent as is the
case in optical networks. Currently, xQSim can simulate pure and
thermalized squeezed states as well as classical thermal state inputs
into the network. This is achieved using a model for thermal squeezed
states which alters the multi-mode input coherence :math:`m(r_{j})` as
:math:`\tilde{m}(r_{j})=(1-\epsilon)m(r_{j})` whilst keeping the input
photon number :math:`n(r_{j})=\bar{n}_{j}` unchanged. This allows users
to easily interpolate between thermal, :math:`\epsilon=1`, and pure
squeezed, :math:`\epsilon=0`, states.

Squeezed thermal states
~~~~~~~~~~~~~~~~~~~~~~~

Thermal states are classical states with fluctuations larger than the
vacuum limit such that their quadrature variances are
:math:`\left\langle :(\Delta\hat{x})^{2}:\right\rangle =\left\langle :(\Delta\hat{y})^{2}:\right\rangle`.

In terms of Fock states, the thermal state density matrix is

.. math:: \hat{\rho}=\frac{1}{1+\bar{n}}\sum_{n=0}^{\infty}\left(\frac{\bar{n}}{1+\bar{n}}\right)^{n}\left|n\right\rangle \left\langle n\right|,

which gives the well known photon number distribution

.. math:: P\left(n\right)=\frac{\bar{n}^{n}}{\left(\bar{n}+1\right)^{n+1}}.\label{eq:thermal state dis}

Thermal states can be used to generate squeezed thermal states with
initial occupation :math:`n_{th}`, which gives
:raw-latex:`\cite{marian1992higher}`:

.. math::

   \begin{aligned}
   \bar{n}= & n_{th}+\left(2n_{th}+1\right)\sinh^{2}\left(r\right)\nonumber \\
   \tilde{m}= & \left(2n_{th}+1\right)\sinh\left(r\right)\cosh\left(r\right).
   \end{aligned}

In the thermalized case, the relationship between coherence and photon
number is modified, since to eliminate :math:`r` one must use the
relationship that

.. math::

   \begin{aligned}
   \frac{\tilde{m}^{2}}{\left(2n_{th}+1\right)^{2}} & =\sinh^{2}\left(r\right)\left(1+\sinh^{2}\left(r\right)\right)\\
    & =\frac{\bar{n}-n_{th}}{\left(2n_{th}+1\right)}\left(1+\frac{\bar{n}-n_{th}}{\left(2n_{th}+1\right)}\right)
   \end{aligned}

Therefore:

.. math::

   \begin{aligned}
   \tilde{m}^{2} & =\left(\bar{n}-n_{th}\right)\left(1+\bar{n}+n_{th}\right)\nonumber \\
    & =\bar{n}+\bar{n}^{2}-\left(n_{th}^{2}+n_{th}\right).
   \end{aligned}

Squeezed thermal states are used as a test case, since one can define
the saturating, or click, detectors in terms of the photon number and
coherence as explained below. An example of such a test is also given in
subsection
`[subsec:Squeezed-thermalised-state-example] <#subsec:Squeezed-thermalised-state-example>`__.

Photon counting
---------------

Photonic networks employed as quantum computers aim to sample from an
output state whose distribution corresponds to the :math:`\#P`-hard
matrix permanent, Hafnian or Torontonian distributions. Which output
probability is sampled depends on the input states to the network, with
Fock states corresponding to the permanent and squeezed states
corresponding to the Hafnian or Torontonian distributions, where the
difference between these distributions comes from the detector used.

The sampled distribution not only depends on the input state but also
the detector type. When photon-number resolving (PNR) detectors are used
one samples either the permanent, given the input is a Fock state, or
the Hafnian distribution for a squeezed state input. The Torontonian
corresponds to the use of saturating, or click, detectors with squeezed
state inputs.

Output samples from linear networks consist of photon count patterns.
The :math:`j`-th detector records :math:`c_{j}=0,1,2,\dots` photon
counts, with a specific output pattern being denoted by the count vector
:math:`\boldsymbol{c}`.

From standard photon counting theory, the projection operator for
observing :math:`c_{j}=0,1,2,\dots` counts is denoted by

.. math:: \hat{p}_{j}(c_{j})=\frac{1}{c_{j}!}:(\hat{n}'_{j})^{c_{j}}e^{-\hat{n}'_{j}}:,\label{eq:photon_counting_proj}

where :math:`:\dots:` denotes normal ordering and
:math:`\hat{n}'_{j}=a_{j}^{\dagger(\text{out})}a_{j}^{(\text{out})}` is
the output photon number.

For PNR detectors, which can discriminate between photon numbers, each
detector is defined by the above projector, with the projection operator
for a specific output pattern given as

.. math:: \hat{P}(\boldsymbol{c})=\bigotimes_{j=i}^{M}\hat{p}_{j}(c_{j}).

The expectation value of the PNR pattern projection operator corresponds
to the Hafnian

.. math:: \text{Haf}=\left\langle \hat{P}(\boldsymbol{c})\right\rangle ,

which is :math:`\#P`-hard to compute at large :math:`M`.

Click detectors saturate for more than one count at a detector.
Therefore, outputs are binary with :math:`c_{j}=1` denoting a detection
event, even if multiple photons hit the same detector, and
:math:`c_{j}=0` is no detection event. From
Eq.(`[eq:photon_counting_proj] <#eq:photon_counting_proj>`__), the click
projection operator is obtained by summing over all :math:`c_{j}>0`
counts such that

.. math::

   \begin{aligned}
   \hat{\pi}(1) & =:\sum_{c_{j}>0}\frac{(\hat{n}'_{j})^{c_{j}}}{c_{j}!}e^{-\hat{n}'_{j}}:\nonumber \\
    & =1-e^{-\hat{n}'_{j}},
   \end{aligned}

which gives the standard saturating detector projection operator

.. math:: \hat{\pi}_{j}(c_{j})=:e^{-\hat{n}'_{j}}\left(e^{\hat{n}'_{j}}-1\right)^{c_{j}}:.\label{eq:click proj}

The projection operator for an pattern output is then similarly defined
as

.. math:: \hat{\Pi}(\boldsymbol{c})=\bigotimes_{j=i}^{M}\hat{\pi}_{j}(c_{j}),

where the expectation value corresponds to the Torontonian distribution

.. math:: \text{Tor}=\left\langle \hat{\Pi}(\boldsymbol{c})\right\rangle .

Exact outputs
~~~~~~~~~~~~~

To test photon count distributions, xQSim uses a modified version of the
click probabilities which can be computed exactly in the limit of a unit
transmission matrix.

Using the thermal state photon number distribution
Eq.(`[eq:thermal state dis] <#eq:thermal state dis>`__), one obtains the
click distributions:

.. math::

   \begin{aligned}
   \pi\left(0\right)=P\left(0\right) & =\frac{1}{\bar{n}+1}\nonumber \\
   \pi\left(1\right)=1-\pi\left(0\right) & =\frac{\bar{n}}{\bar{n}+1}.
   \end{aligned}

Substituting the thermal squeezed state modified photon number the
probability of a vacuum state is :raw-latex:`\cite{marian1992higher}`:

.. math::

   \begin{aligned}
   \pi\left(0\right) & =\frac{1}{n_{th}+1}\left(1+\frac{2n_{th}+1}{\left(n_{th}+1\right)^{2}}\sinh^{2}\left(r\right)\right)^{-(1/2)}\\
    & =\left(\bar{n}-n_{th}+\left(n_{th}+1\right)^{2}\right)^{-(1/2)}\\
    & =\left(1+\bar{n}+n_{th}+n_{th}^{2}\right)^{-(1/2)}\\
    & =\left(\left(1+\bar{n}\right)^{2}-\tilde{m}^{2}\right)^{-(1/2)}.
   \end{aligned}

Hence, by using known results for a photon number distribution of a
squeezed thermal state :raw-latex:`\cite{marian1992higher}`, combined
with the definitions of :math:`\bar{n}` and :math:`\tilde{m}`, the
probability of a vacuum state and a non-vacuum or click state are:

.. math::

   \begin{aligned}
   \left\langle \hat{\pi}\left(0\right)\right\rangle  & =\frac{1}{\sqrt{\left(1+\bar{n}\right)^{2}-\tilde{m}^{2}}}\nonumber \\
   \left\langle \hat{\pi}\left(1\right)\right\rangle  & =1-\frac{1}{\sqrt{\left(1+\bar{n}\right)^{2}-\tilde{m}^{2}}}.
   \end{aligned}

Example applications of this result is presented in subsection
`[subsec:Squeezed-thermalised-state-example] <#subsec:Squeezed-thermalised-state-example>`__.

Intensity correlations
----------------------

xQSim generates comparisons of two types of correlations: Glauber
intensity correlations and grouped correlations, also referred to as a
grouped count probabilities (GCPs).

Intensity correlation simulations can only be performed on photon number
operator observables. Therefore, although they are valid for determining
photon number probabilities in click experiments, they correspond
directly to PNR detector outputs. Meanwhile GCPs are only valid for
click detectors. Although methods are available which convert PNR
detectors to click detectors, direct binning methods for PNR outputs
will be included in a sequential updates.

Glauber’s :math:`n`-th order intensity correlation is defined as

.. math:: G^{(n)}(c_{j})=\left\langle :(\hat{n}'_{j})^{c_{j}}\dots(\hat{n}'_{M})^{c_{M}}:\right\rangle ,

where :math:`n=\sum c_{j}` is the correlation order. Multi-mode Glauber
correlations determine the probability of detecting :math:`n` photons at
:math:`n` modes.

The normal ordering requirement causes all creation operators to the
right and all annihilation operators to the left. For example, the
second-order correlation

.. math:: G^{(2)}=\left\langle a_{1}^{\dagger(\text{out})}a_{2}^{\dagger(\text{out})}a_{2}^{(\text{out})}a_{1}^{(\text{out})}\right\rangle ,

corresponds to detecting one photon at mode :math:`1` and one at mode
:math:`2`.

Upon reordering using the standard Bose commutation relations
Eq.(`[eq:bose_comm_rel] <#eq:bose_comm_rel>`__), one obtains

.. math:: G^{(2)}=\left\langle a_{1}^{\dagger(\text{out})}a_{2}^{(\text{out})}\right\rangle \left\langle a_{2}^{\dagger(\text{out})}a_{1}^{(\text{out})}\right\rangle +\left\langle a_{1}^{\dagger(\text{out})}a_{1}^{(\text{out})}\right\rangle \left\langle a_{2}^{\dagger(\text{out})}a_{2}^{(\text{out})}\right\rangle .

The first term describes non-local correlations which is the
interference of photons between detectors, whilst the second term
describes the photon intensity at a detector or local correlations.

If the mean number of photons is small, such that a detector will only
ever observe one photon, the intensity correlation becomes a coincidence
count

.. math:: P_{N}=\left\langle \prod_{j}\hat{n}'_{j}\right\rangle ,

as we assume photons do not interfere at detectors, removing non-local
correlations.

Grouped correlations
--------------------

Grouped count probabilities (GCPs) are the main observable correlation
implemented by xQSim and are only valid for click detectors.

GCPs are defined as

.. math:: \mathcal{G}_{\boldsymbol{S}}^{(n)}(\boldsymbol{m})=\left\langle \prod_{j=1}^{d}\left[\sum_{\sum c_{i}=m_{j}}\hat{\Pi}_{S_{j}}(\boldsymbol{c})\right]\right\rangle ,\label{eq:GCP}

where :math:`\boldsymbol{m}=(m_{1},\dots,m_{d})` are the observed
grouped counts in :math:`d`-dimensions and
:math:`\boldsymbol{S}=(S_{1,}S_{2},\dots)` is a vector of disjoint
subsets of :math:`\boldsymbol{M}=(M_{1},M_{2},\dots)` modes.

Each grouped count is obtained by summing over binary patterns
:math:`m_{j}=\sum_{i}^{M}c_{i}`. Therefore, grouped counts contain
:math:`k` bins, with each bin corresponding to the total number of
clicks in each pattern. In one-dimension, GCPs are the probability of
observing :math:`m` counts in any pattern with :math:`n=M` and
:math:`S=\{1,\dots,M\}`. This observable is called total counts.

For larger dimensions, each grouped count sums over detector outputs for
a subset of modes only such that :math:`m_{j}=\sum_{i}^{M/d}c_{i}`. The
modes in each subset are denoted in the vector :math:`\boldsymbol{S}`.
For example, in two-dimensions one has subsets
:math:`\boldsymbol{S}=(S_{1},S_{2})` which contain modes

.. math::

   \begin{aligned}
   S_{1} & =\left\{ 1,\dots,\frac{M}{2}\right\} \nonumber \\
   S_{2} & =\left\{ \frac{M+2}{2},\dots,M\right\} .
   \end{aligned}

The output GCP is then a joint probability of observing
:math:`m_{1}=\sum_{i=1}^{M/2}c_{i}` and
:math:`m_{2}=\sum_{i=M/2+1}^{M}c_{i}` grouped counts with
:math:`k=(M/2+1)^{2}` total bins.

The implied segregation of output modes in the two-dimensional example
above is that :math:`S_{1}` will always contain the first :math:`M/d`
modes, :math:`S_{2}` the next :math:`M/d+1\rightarrow2M/d` modes, and so
on for larger dimensions. However, there is no practical restriction on
the output modes each subset can contain.

Therefore, by randomly permuting each binary pattern we can change the
output modes that are contained in each subset giving

.. math:: \frac{\binom{M}{M/d}}{d}=\frac{M!}{d(M/d)!(M-M/d)!},

possible ways of generating :math:`m_{1},\dots,m_{d}` grouped counts
without repeating a specific permutation.

For example, when :math:`M=4` and :math:`d=2`, including the standard
division, there are :math:`3` different orderings of outputs modes with
subsets

.. math::

   \begin{aligned}
   \boldsymbol{S} & =(S_{1},S_{2})=(\{1,2\},\{3,4\}),\nonumber \\
   \boldsymbol{S} & =(S_{1},S_{2})=(\{1,3\},\{2,4\}),\nonumber \\
   \boldsymbol{S} & =(S_{1},S_{2})=(\{1,4\},\{2,3\}).
   \end{aligned}

Each permutation generates a different correlation, where we assume the
commutation of GCP probabilities with subsets
:math:`(\{1,3\},\{2,4\})=(\{2,4\},\{1,3\})`.

This permutation only changes the multidimensional GCP simulations, as
in the total count case all modes are contained in the same subset
:math:`S=\{1,\dots,M\}`. This is also the case when simulating marginal
probabilities, which are obtained by setting :math:`n<M` such that
:math:`M-n` inputs are ignored. The first-order marginal, :math:`n=1`,
is called the click correlation,
:math:`\left\langle \hat{\pi}_{j}(1)\right\rangle`, and determines the
probability of observing a click at the :math:`j`-th detector.

Phase-space sampling
====================

To simulate output probabilities, xQSim uses phase-space
representations. As already explained, xQSim *does not* generate photon
counts, which is the :math:`\#P`-hard task implemented by experiments.
Instead, phase-space representations allow users to compute
*distributions and moments* of the resulting output distributions of
linear networks.

The outputs in phase-space are continuous real or complex variables
whose stochastic moments are equal to moments of the experimental
distributions, apart from sampling errors due to finite numbers of
experimental and theoretical counts. This assumes that the parameters
are precisely known, and do not have noise or fluctuations.

Glauber P-representation
------------------------

The :math:`M`-mode Glauber diagonal P-representation expands the density
matrix as a sum of diagonal coherent state projectors

.. math:: \hat{\rho}=\int P(\boldsymbol{\alpha})\left|\boldsymbol{\alpha}\right\rangle \left\langle \boldsymbol{\alpha}\right|d^{2M}\boldsymbol{\alpha},

where the distribution :math:`P(\boldsymbol{\alpha})` is a positive and
non-singular distribution over multimode coherent state amplitudes
:math:`\boldsymbol{\alpha}=[\alpha_{1},\dots,\alpha_{M}]` for classical
states.

However, the diagonal P-representation famously breaks down for certain
quantum states, generating non-positive and singular distributions. This
is due to the lack of off-diagonal coherent state amplitudes needed to
represent such nonclassical superpositions.

Positive P-representation
-------------------------

Part of a family of generalized P-representations developed to extend
Glauber’s diagonal P-representation to quantum states
:raw-latex:`\cite{Drummond_generalizedP1980}`, the normally ordered
positive-P representation always generates a non-singular and positive
distribution for any quantum state.

The density matrix is defined as an expansion over a multidimensional
subspace of the complex plane:

.. math:: \hat{\rho}=\iint P(\boldsymbol{\alpha},\boldsymbol{\beta})\hat{\Lambda}(\boldsymbol{\alpha},\boldsymbol{\beta})\text{d}^{2M}\boldsymbol{\alpha}\text{d}^{2M}\boldsymbol{\beta},

where :math:`P(\boldsymbol{\alpha},\boldsymbol{\beta})` is the
positive-P distribution over coherent state amplitudes
:math:`\boldsymbol{\alpha},\boldsymbol{\beta}`. The off-diagonal
coherent state projector

.. math:: \hat{\Lambda}(\boldsymbol{\alpha},\boldsymbol{\beta})=\frac{\left|\boldsymbol{\alpha}\right\rangle \left\langle \boldsymbol{\beta}^{*}\right|}{\left\langle \boldsymbol{\beta}^{*}|\boldsymbol{\alpha}\right\rangle },

doubles the classical phase-space dimension, allowing off-diagonal
amplitudes :math:`\boldsymbol{\beta}\neq\boldsymbol{\alpha}^{*}` to
exist.

One can restrict the distribution to a classical phase-space with
:math:`\boldsymbol{\beta}=\boldsymbol{\alpha}^{*}`, in which case the
diagonal P-representation is obtained as a special case of the positive
P-representation via the substitution
:math:`P(\boldsymbol{\alpha},\boldsymbol{\beta})=P(\boldsymbol{\alpha})\delta(\boldsymbol{\alpha}^{*}-\boldsymbol{\beta})`.
However, for squeezed states, this will lead to the singular behavior
that is already known.

Moments of the positive-P distribution are equivalent to normally
ordered operator moments

.. math::

   \begin{aligned}
   \left\langle \hat{a}_{j_{1}}^{\dagger},\dots,\hat{a}_{j_{n}}\right\rangle  & =\left\langle \beta_{j_{1}},\dots,\alpha_{j_{n}}\right\rangle _{P}\nonumber \\
    & =\iint P(\boldsymbol{\alpha},\boldsymbol{\beta})[\beta_{j_{1}},\dots,\alpha_{j_{n}}]\text{d}^{2M}\boldsymbol{\alpha}\text{d}^{2M}\boldsymbol{\beta},
   \end{aligned}

where :math:`\left\langle \dots\right\rangle` denotes a quantum
expectation value and :math:`\left\langle \dots\right\rangle _{P}` is
the positive-P probability average.

Although the diagonal P-representation is unsuitable to simulate
squeezed or entangled states, other classical phase-space distributions
exist with positive distributions for quantum states. These are the
symmetrically orders Wigner representation and anti-normally ordered
Q-function.

Wigner representation
---------------------

The :math:`M`-mode Wigner representation is defined as the Fourier
transform of the symmetrically ordered characteristic function such that

.. math:: W(\boldsymbol{\alpha})=\frac{1}{\pi^{2M}}\int\text{d}^{2}\boldsymbol{z}\text{Tr}\left\{ \hat{\rho}e^{i\boldsymbol{z}(\hat{a}-\boldsymbol{\alpha})+i\boldsymbol{z}^{*}(\hat{a}^{\dagger}-\boldsymbol{\alpha}^{*})}\right\} ,

where :math:`\text{Tr \{\ensuremath{\dots}\}}` is the trace and
:math:`\boldsymbol{z}` is a complex vector.

Although the Wigner function always exists as a real-valued function on
phase-space for the density operator, or any other hermitian operator,
the resulting probability distribution need not be positive. This is why
the Wigner distribution is referred to as a quasi-probability. However
for thermal and squeezed states, the Wigner distribution is positive.

Despite the positive distribution, the Wigner function is only valid for
symmetrically ordered operator products. Symmetric ordering, denoted
:math:`\{\dots\}_{sym}`, is the average over all possible combinations
of creation and annihilation operators, for example

.. math::

   \begin{aligned}
   \{\hat{a}^{\dagger}a\}_{sym} & =\frac{1}{2}(\hat{a}\hat{a}^{\dagger}+\hat{a}^{\dagger}\hat{a})\label{eq:sym_number_op}\\
   \{\hat{a}^{\dagger}\hat{a}^{2}\}_{sym} & =\frac{1}{3}(\hat{a}^{2}\hat{a}^{\dagger}+\hat{a}\hat{a}^{\dagger}\hat{a}+\hat{a}^{\dagger}\hat{a}^{2}).
   \end{aligned}

This ordering requirement makes applications to normally ordered
detectors both cumbersome, as one must reorder all operators to normal
order, and inaccurate, as seen from
Eq.(`[eq:sym_number_op] <#eq:sym_number_op>`__), where the expectation
value of the symmetrically ordered number operator becomes

.. math:: \left\langle \{\hat{a}^{\dagger}a\}_{sym}\right\rangle =|\alpha|^{2}+\frac{1}{2}.

Therefore, the Wigner function adds half a quantum of vacuum noise per
mode causing a rapid increase sampling errors, making the Wigner
function unsuitable for simulations of network output probabilities.

However, the Wigner function is ideal for simulating squeezed state
quadrature operators, Eqs.(), as these are measured via homodyne
detectors which are symmetrically ordered.

Q-function
----------

The standard form of the anti-normally ordered :math:`M`-mode Q-function
is

.. math:: Q(\boldsymbol{\alpha})=\frac{1}{\pi^{M}}\left\langle \boldsymbol{\alpha}|\hat{\rho}|\boldsymbol{\alpha}\right\rangle ,

and, like the Wigner function, can be expressed as the Fourier transform
of the anti-normally ordered characteristic function.

The Q-function distribution is always positive but is only defined for
anti-normally ordered operator products with moments being obtained as

.. math::

   \begin{aligned}
   \left\langle \hat{a}_{j_{1}},\dots,\hat{a}_{j_{n}}^{\dagger}\right\rangle  & =\left\langle \alpha_{j_{1}},\dots,\alpha_{j_{n}}^{*}\right\rangle _{Q}\nonumber \\
    & =\int Q(\boldsymbol{\alpha})[\alpha_{j_{1}},\dots,\alpha_{j_{n}}^{*}]\text{d}^{2M}\boldsymbol{\alpha},
   \end{aligned}

where :math:`\left\langle \dots\right\rangle _{Q}` denotes a
Q-distribution average.

However, like the Wigner function, operators must be reordered for
applications to normally ordered detectors. Using the standard bosonic
commutation relations, Eqs.(`[eq:bose_comm_rel] <#eq:bose_comm_rel>`__),
the expectation value of the number operator is

.. math:: \left\langle \{a\hat{a}^{\dagger}\}_{anti}\right\rangle =|\alpha|^{2}+1.

The Q-function adds a quantum of vacuum noise per mode, generating the
largest increase in sampling errors of any phase-space representation
when used to simulate normally ordered detectors. This accumulation of
vacuum noise for multimode networks rapidly causes the Q-function to
become inaccurate for simulating linear networks.

:math:`\sigma`-ordering
-----------------------

The amount of vacuum noise added by each representation can be used to
define the operator ordering parameter :math:`\sigma`, where
:math:`\sigma=0` corresponds to normal ordering, :math:`\sigma=1/2`
symmetric ordering and :math:`\sigma=1` anti-normal ordering.

The ability to define a common ordering scheme arises from writing the
Wigner and Q-function distributions as convolutions of the positive
P-representation

.. math:: P_{\sigma}(\boldsymbol{\alpha})=\frac{1}{(\pi\sigma)^{M}}\int P(\boldsymbol{\alpha}_{0},\boldsymbol{\beta}_{0})e^{-(\boldsymbol{\alpha}-\boldsymbol{\alpha}_{0})(\boldsymbol{\alpha}^{*}-\boldsymbol{\beta}_{0})/\sigma}\text{d}^{2M}\boldsymbol{\alpha}\text{d}^{2M}\boldsymbol{\beta},

where :math:`P_{\sigma}(\boldsymbol{\alpha})` is a
:math:`\sigma`-ordered representation,
:math:`P(\boldsymbol{\alpha}_{0},\boldsymbol{\beta}_{0})` is the
positive-P distribution and
:math:`\boldsymbol{\alpha}_{0},\boldsymbol{\beta}_{0}` are used to
denote the normal ordered nonclassical phase-space variables whilst
:math:`\boldsymbol{\alpha},\boldsymbol{\alpha}^{*}` denotes a classical
phase-space which is valid for :math:`\sigma=1/2,1`.

Operator moments for any ordering can now be obtained via

.. math::

   \begin{aligned}
   \left\langle \left\{ \hat{a}_{j_{1}}^{\dagger},\dots,\hat{a}_{j_{n}}\right\} _{\sigma}\right\rangle  & =\left\langle \alpha_{j_{1}}^{*},\dots,\alpha_{j_{n}}\right\rangle _{\sigma}\nonumber \\
    & =\int P_{\sigma}(\boldsymbol{\alpha})[\alpha_{j_{1}}^{*},\dots,\alpha_{j_{n}}]\text{d}^{2M}\boldsymbol{\alpha}.
   \end{aligned}

Numerical methods
=================

The section outlines the numerical methods and statistical tests
implemented by xQSim to simulate linear network output distributions and
perform comparisons with either experimental data, or exact tests.

Input-output samples
--------------------

To simulate linear networks in phase-space, one must first generate
initial stochastic samples. This is achieved using the
:math:`\sigma`-ordering scheme as stochastic samples for any Gaussian
input state in any representation are generated following:

.. math::

   \begin{aligned}
   \alpha_{j} & =\frac{1}{2}\left(\Delta_{\sigma x_{j}}w_{j}+i\Delta_{\sigma y_{j}}w_{j+M}\right)\nonumber \\
   \beta_{j} & =\frac{1}{2}\left(\Delta_{\sigma x_{j}}w_{j}-i\Delta_{\sigma y_{j}}w_{j+M}\right),
   \end{aligned}

where :math:`\left\langle w_{j}w_{k}\right\rangle =\delta_{jk}` are real
Gaussian noises and

.. math::

   \begin{aligned}
   \Delta_{\sigma x_{j}}^{2} & =2(n_{j}+\sigma+\tilde{m}_{j})\nonumber \\
   \Delta_{\sigma y_{j}}^{2} & =2(n_{j}+\sigma-\tilde{m}_{j}),\label{eq:quad_var_altered}
   \end{aligned}

are thermal squeezed state quadrature variances which are altered from
the pure squeezed state definitions Eqs.(`[eq:x-quad] <#eq:x-quad>`__)
and (`[eq:y-quad] <#eq:y-quad>`__).

For normally ordering, the input amplitudes
:math:`\boldsymbol{\alpha},\boldsymbol{\beta}` are converted to outputs
as

.. math::

   \begin{aligned}
   \boldsymbol{\alpha}' & =\boldsymbol{T\alpha}\nonumber \\
   \boldsymbol{\boldsymbol{\beta}}' & =\boldsymbol{T}^{*}\boldsymbol{\beta},
   \end{aligned}

which follows from Eq.(`[eq:linear_combo] <#eq:linear_combo>`__).
However for non-normally ordered methods, additional vacuum noise
arising from the reservoir modes must be included.

This is achieved using a hermitian decoherence matrix

.. math:: \boldsymbol{D}=\boldsymbol{I}-\boldsymbol{T}^{\dagger}\boldsymbol{T},

with decomposition
:math:`\boldsymbol{D}=\boldsymbol{U}\boldsymbol{\lambda}^{2}\boldsymbol{U}^{\dagger}`
where
:math:`\boldsymbol{B}=\boldsymbol{U}\boldsymbol{\lambda}\boldsymbol{U}^{\dagger}`
is the matrix square root and :math:`\boldsymbol{\lambda}` is a
diagonal, positive matrix. The output amplitudes when :math:`\sigma>0`
are then obtained as

.. math:: \boldsymbol{\alpha}'=\boldsymbol{T\alpha}+\sqrt{\frac{\sigma}{2}}\boldsymbol{B}(\boldsymbol{u}+i\boldsymbol{v}),

where :math:`\boldsymbol{\beta}'=\boldsymbol{\alpha}^{\prime*}` as we
are in a classical phase-space.

Grouped correlations computation
--------------------------------

GCPs are readily simulated in phase-space using the positive-P
representation by replacing the normally ordered projection operator
Eq.(`[eq:click proj] <#eq:click proj>`__) with the positive-P observable

.. math:: \pi_{i}(c_{i})=:e^{-n'_{i}}\left(e^{n'_{i}}-1\right)^{c_{i}},

where :math:`n'_{i}=\alpha'_{i}\beta'_{i}` is the output photon number.

The summation over exponentially many patterns implemented by GCPs (see
Eq.(`[eq:GCP] <#eq:GCP>`__) is simulated using a multidimensional
inverse discrete Fourier transform

.. math::

   \begin{aligned}
   \tilde{\mathcal{G}}_{\boldsymbol{S}}^{(n)}(\boldsymbol{k}) & =\left\langle \prod_{j=1}^{d}\bigotimes_{i\in S_{j}}\left(\pi_{i}(0)+\pi_{i}(1)e^{-ik_{j}\theta_{j}}\right)\right\rangle _{P},\nonumber \\
   \mathcal{G}_{\boldsymbol{S}}^{(n)}(\boldsymbol{m}) & =\frac{1}{\prod_{j}(M_{j}+1)}\sum_{\boldsymbol{k}}\tilde{\mathcal{G}}_{\boldsymbol{S}}^{(n)}(\boldsymbol{k})e^{i\sum k_{j}\theta_{j}m_{j}},
   \end{aligned}

where :math:`\theta_{j}=2\pi/(M_{j}+1)` and :math:`k_{j}=0,\dots,M_{j}`.

The Fourier transform removes all patterns which don’t contain
:math:`\boldsymbol{m}` counts, in doing this the Fourier transform
simulates all possible correlations generated in a network. This reduces
an otherwise computationally complex task into a highly efficient and
scalable one, allowing comparisons to be performed on experimental
correlations of any order.

Statistical tests 
------------------

The data generated and compared with experiment is in the form of
probabilities of clicks or binned click patterns. xQSim implements two
statistical tests: chi-square and :math:`Z`-statistic tests.

Chi-square tests
~~~~~~~~~~~~~~~~

If :math:`n` observations in a random sample from a population are
classified into classes with observed numbers :math:`x_{i}` (for
:math:`i=1,2,\ldots,k`), and a null hypothesis gives the probability
:math:`p_{i}` that an observation falls into the :math:`i`-th class,
then the expected numbers are :math:`m_{i}=np_{i}` .

The limiting distribution of the quantity given below is the
:math:`\chi^{2}` distribution:

.. math::

   \begin{aligned}
   \chi^{2} & =\sum_{i=1}^{k}\frac{(x_{i}-m_{i})^{2}}{m_{i}}\\
    & =\sum_{i=1}^{k}\frac{(x_{i}/n-p_{i})^{2}}{p_{i}/n}.
   \end{aligned}

For our purposes, define an experimental probability estimate as
:math:`p_{i}^{e}=x_{i}/n`, then

.. math::

   \begin{aligned}
   \chi^{2} & =\sum_{i=1}^{k}\frac{(p_{i}^{e}-p_{i})^{2}}{\sigma_{i}^{2}}
   \end{aligned}

Here, :math:`\sigma_{i}^{2}=p_{i}/n`, is the estimated experimental
variance. This is only valid for click detectors, or PNR detectors when
photon flux is small, as binary outputs can be modeled as Poissonian.
For larger photon numbers this is not the case as multiple photons can
be detected simultaneously.

Typically, counts less that :math:`x_{i}^{min}\sim10` are ignored, as
the distribution is no longer Gaussian for small counts. The program
produces :math:`\chi^{2}` tests that include an estimate of simulation
errors:

.. math:: \sigma_{i}^{2}=p_{i}/n+\sigma_{i}^{s2}

Note that this can also be used to compare simulations with other
analytic comparison theories, not just with experiment.

Z-statistic tests
~~~~~~~~~~~~~~~~~

The :math:`Z`-statistic, or :math:`Z`-score, test determines how many
standard deviations a test statistic, :math:`X`, is from its expected,
normally distributed mean and is defined as

.. math:: Z=\frac{X-\mu}{\sigma},

where :math:`\mu` and :math:`\sigma` are the mean and standard deviation
of a normal distribution, respectively.

In the limit :math:`k\rightarrow\infty`, the chi-square distribution of
the test statistic approaches a normal distribution via the central
limit theorem. Typically this convergence is slow, however using the
Wilson-Hilferty (WH) transformation, an accurate convergence can be
achieved when :math:`k\geq10`.

Using the WH transformed chi-square statistic
:math:`\left(\chi^{2}/k\right)^{1/3}`, the :math:`Z`-statistic of the
chi-square distribution is

.. math:: Z=\frac{\left(\chi^{2}/k\right)^{1/3}-(1-2/(9k))}{\sqrt{2/(9k)}},

for comparisons with :math:`k\geq10` distinct classes.

The :math:`Z`-statistic is used to determine the randomness of output
patterns, as large :math:`Z` values could indicate experimental output
patterns are not occurring randomly. A threshold of :math:`Z>6` is used
to define outputs with extremely small probabilities of occurring.

The :math:`Z`-statistic becomes particularly powerful when used in
conjunction with random permutations of output patterns, as repeatedly
observing large :math:`Z` values indicates outputs with very small
probabilities are being continuously observed. This could indicate
systematic errors in an experimental network are causing non-random
behavior, such as more :math:`0's` than :math:`1's` in binary patterns,
to occur.

xQSim operation
===============

The initial xQSim software distributions consists of Matlab functions,
including *xQSim* itself, together with functions called by *xQSim*.
There are also test scripts with inputs that can be modified. The
functions used can be replaced as required for different applications.
The input is a sequence of parameter structures in a cell array. The
output data is a nested cell array giving first the sequence index, then
one graph index for each average correlation calculated.

The output data is compatible with the *xGraph* multidimensional batch
graphics program, documented separately. Other graphics codes can be
used, too, if compatible with the data files. An example and description
of the basic functions available is given below.

xQSim example
-------------

xQSim is the quantum simulation code. To run this, an input m-file is
needed to define the simulation parameters and run the code. A simple
example is given below. This makes use of xGraph, an accompanying batch
graphics program, but use of xGraph is optional. More examples are given
in section. `[sec:Examples] <#sec:Examples>`__ and the xQSimExamples
folder.

.. container:: center

 

xQSim parameters
----------------

**The input is a cell array of parameter structures p.** The code
generates simulation data and sampling errors in an output cell data
array :math:`d,` including comparative experimental or analytic data if
required. An input cell array can be replaced by a single parameter
structure if there is only one simulation in a sequence. Otherwise, the
cell array defines a sequence of network transformations.

In general, simulations can treat an arbitrary sequence of networks and
parameters. Some inputs are optional, and have specified defaults. These
allow the input parameter list to be shortened. Full input parameter
lists are in Sec (`[sec:xqSIM-reference] <#sec:xqSIM-reference>`__).

The most used parameter inputs are:

.. container:: center

   +-------------+-----------------+-----------------+-----------------+
   | Label       | Type            | Default         | Description     |
   +=============+=================+=================+=================+
   | *deco*      | string          | ”               | Decoherence     |
   |             |                 |                 | factors used    |
   |             |                 |                 | for             |
   |             |                 |                 | optimization    |
   +-------------+-----------------+-----------------+-----------------+
   | CO          | integer         | None            | Correlation     |
   |             |                 |                 | order           |
   +-------------+-----------------+-----------------+-----------------+
   | *compare*   | function        | []              | Optional        |
   |             | handles         |                 | comparison      |
   |             |                 |                 | functions       |
   +-------------+-----------------+-----------------+-----------------+
   | *ensembles* | vector          | [1,1,1]         | Size of vector, |
   |             |                 |                 | serial,         |
   |             |                 |                 | parallel        |
   |             |                 |                 | ensemble        |
   +-------------+-----------------+-----------------+-----------------+
   | :math:`eps` | vector          | 0               | An              |
   |             |                 |                 | n-dimensional   |
   |             |                 |                 | decoherence     |
   |             |                 |                 | factor          |
   +-------------+-----------------+-----------------+-----------------+
   | M           | integer         | 1               | Total number of |
   |             |                 |                 | modes           |
   +-------------+-----------------+-----------------+-----------------+
   | *matrix*    | matrix function | Identity        | An              |
   |             |                 |                 | :m              |
   |             |                 |                 | ath:`M\times M` |
   |             |                 |                 | transfer matrix |
   |             |                 |                 | function        |
   +-------------+-----------------+-----------------+-----------------+
   | *method*    | integer         | 1               | Phase-space     |
   |             |                 |                 | method:         |
   |             |                 |                 | :math:`m=1,2,3` |
   +-------------+-----------------+-----------------+-----------------+
   | N           | integer         | 1               | Number of       |
   |             |                 |                 | excited input   |
   |             |                 |                 | modes           |
   +-------------+-----------------+-----------------+-----------------+
   | *name*      | character       | ”               | Name of         |
   |             |                 |                 | simulation      |
   +-------------+-----------------+-----------------+-----------------+
   | O           | vector          | :math:`[]`      | Vector of       |
   |             |                 |                 | various         |
   |             |                 |                 | correlation     |
   |             |                 |                 | orders          |
   +-------------+-----------------+-----------------+-----------------+
   | *observe*   | function        | :math:          | Observable      |
   |             | handles         | `\{@(a,p)\,a\}` | functions       |
   +-------------+-----------------+-----------------+-----------------+
   | *permute*   | vector          | :math:`[        | Random          |
   |             |                 | 1,2,3,\dots,M]` | permutation of  |
   |             |                 |                 | outputs         |
   +-------------+-----------------+-----------------+-----------------+
   | *r*         | vector or       | 0               | An              |
   |             | function        |                 | n-dimensional   |
   |             |                 |                 | squeezing       |
   |             |                 |                 | vector          |
   +-------------+-----------------+-----------------+-----------------+
   | *t*         | vector          | 1               | An              |
   |             |                 |                 | n-dimensional   |
   |             |                 |                 | transmission    |
   |             |                 |                 | factor          |
   +-------------+-----------------+-----------------+-----------------+

-  Note that vectors :math:`r`, :math:`eps`, :math:`t` are
   :math:`N`-dimensional. They are expanded to :math:`N` dimensions by
   repeating the last element, if they are less than
   :math:`N`-dimensional.

-  If :math:`ensembles(1)>1`, all calculations are repeated in parallel
   and averaged using low-level, single core vector methods.

-  If :math:`ensembles(2)>1`, calculations are repeated sequentially, in
   a loop, in order to estimate sampling errors.

-  If :math:`ensembles(3)>1`, calculations are repeated using multi-core
   parallel loops. This is also used to estimate sampling errors.

-  If :math:`method>1`, an alternative phase-space method is used:
   Wigner or Q. The default is the +P method.

-  The squeezing vector **:math:`\bm{r}`** and transfer matrix
   :math:`matrix` can be input as numbers or as a function handle. The
   transmission factor :math:`t` is an additional prefactor applied to
   inputs prior to the measured transmission :math:`matrix` to allow
   additional fine-tuning.

Other notation used in the input structure is given in the associated
preprint. One dataset is generated per observe function, but this can
produce more than one plot, depending on the graphics options specified.

Simulation notes
----------------

General
~~~~~~~

-  Starting from a vacuum state, :math:`\bm{a}^{(0)}`, xQSim iteratively
   combines the :math:`n`-th output :math:`\bm{a}^{(n)}` with a locally
   generated Gaussian, or another state in general. The quantum state is
   transformed through a network to generate :math:`\bm{a}^{(n+1)}` and
   detected.

-  Each network is repeated :math:`cyc` times, with a default of
   :math:`cyc=1`. If :math:`cyc>1`, output data is indexed by cycle, and
   graphs vs cycle number are made. If :math:`cyc>1` and :math:`re>0`,
   the field is recycled with recycling amplitude :math:`re`.

-  The :math:`gen` code generates the input, checks if random
   permutations are present and simulates the network.

Optimizing decoherence & transmission
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When using xQSim to compare theoretical and experimental quantum
networks, it is recommended that the first simulation use :math:`eps=0`
and :math:`t=1`. This corresponds to pure squeezed state inputs as
:math:`eps=\epsilon` (see subsection.
`[subsec:Quantum-input-states] <#subsec:Quantum-input-states>`__) whilst
:math:`t` corresponds to measurement errors in the transmission matrix.

Once completed, users may wish to simulate decoherence effects. Although
exact values of :math:`eps` and :math:`t` are up to users discretion, it
is recommended to use Matlab’s *fminsearch* function to find optimal
fitting values. These correspond to the lowest obtainable
:math:`\chi^{2}` output. An example of how to implement *fminsearch* in
xQSim is given below for the script *xQSim_165W_experiment.m* contained
in the folder *xQSimExamples*.

To start *fminsearch* the following prompt is inserted into the Command
Window:

.. container:: center

 

This will run xQSim multiple times for different parameters of
:math:`eps` and :math:`t` until it reaches a minimum at which point it
will output the optimal values of :math:`eps` and :math:`t`.

Some general considerations when using *fminsearch* is that it will
likely take multiple hours to complete, assuming the user has access to
Matlab’s parallel computing toolbox. Without the parallel toolbox
computation time will increase significantly. If this is the case, a
manual optimizing route may be more efficient.

To reduce computation time, *fminsearch* can be stopped before it has
found the absolute minimum. This is due to two reasons:

#. Since xQSim simulates stochastic samples, output probabilities will
   vary slightly between runs causing *fminsearch* to run longer than
   may be necessary.

#. :math:`\chi^{2}` output differences between simulation runs becomes
   negligible once :math:`eps` and :math:`t` are accurate to
   :math:`\approx4/5` decimal places. Since *fminsearch* will continue
   repeating simulations until a minimum is found, the increase in
   computation for greater decimal accuracy may outweigh the negligible
   improvement in :math:`\chi^{2}` results.

If the user wishes to have the option of stopping *fminsearch* early, it
is recommended to use the parameter *p.deco*. *fminsearch* doesn’t
output the values of :math:`eps` and :math:`t` it uses in each
simulation run, only outputting them once it’s fully completed.
Therefore, *p.deco* prints the values of :math:`eps` and :math:`t`
before each simulation run, allowing the user to know what decoherence
factors the most recent simulation run has used.

**Caution** - When running *fminsearch* be sure to either comment out or
remove the graphics program *xGraph* from the script as once
*fminsearch* is complete, Matlab will generate plots for every
simulation run. These comparison plots are not necessary when optimizing
decoherence and transmission and may cause Matlab to crash.

.. container:: center

 

Data extraction
~~~~~~~~~~~~~~~

Data from both :math:`100`-mode and :math:`144`-mode experiments of
Zhong et al :raw-latex:`\cite{zhong2020quantum,Zhong2021Phase}` have
been extracted and are contained within the folder
*xQSimGBSExperiments*. Due to their size, raw data files are not
provided but can be obtained from :raw-latex:`\cite{Raw100,Raw144}`.

If the user is required to extract additional observable data, xQSim
contains three data extraction algorithms:

-  *qcounts*: Extracts data from binary files with big endian encoding.
   Corresponds to experiment :raw-latex:`\cite{zhong2020quantum}`.
   Algorithm is run separately from the input m-file simulation script
   and is only valid when :math:`M=100`.

-  *qcountsbe*: Extracts data from the same binary encoding as *qcounts*
   but is integrated into the input m-file and is valid for any mode
   number.

-  *qcountsle*: Extracts data from binary files with little endian
   encoding. Corresponds to experiment
   :raw-latex:`\cite{Zhong2021Phase}`. Like *qcountsbe*, *qcountsle* is
   integrated into the input m-file and is valid for any mode number.

An example implementation of *qcountsle* is supplied below. To allow
phase-space simulations to be performed immediately after extraction,
the experimental counts integer *Count* is output. When using
*qcountsbe* or *qcountsle*, the integer variable *bits* is required to
input the bit-type of the encoded data file. Although *qcountsbe* and
*qcountsle* have been generalized, this is limited to data from
experiments :raw-latex:`\cite{zhong2020quantum,Zhong2021Phase}` since
every experiment may encode data differently.

The only time user’s may wish to extract additional data is to perform
random permutation tests, which require permutations to be applied
before binning. In this case, one can use *qcounts_permute* and
*qcountsle_permute* for :math:`100`-mode and :math:`144`-mode data,
respectively. The only addition in these scripts compared to the
standard extraction code is the use of Matlab’s *randperm* function. The
:math:`1\times M` random permutation vector applied to each pattern is
then saved as *randp.mat*, which is called from the main Matlab
directory using the function *xqpermutation* and set as the par mater
*p.permute*. This permutation vector is then applied to the rows of the
transmission matrix for use in phase-space simulations.

More details on random permutations can be found in the appropriate
example located in section `[sec:Examples] <#sec:Examples>`__.

.. container:: center

 

Data structures in xQSim and xGraph
-----------------------------------

xQSim inputs
~~~~~~~~~~~~

When *xQSim* is used, it is called with the argument (*input*). Each
simulation is defined as a cell array of structures:

.. math:: input:=\{p_{1},p_{2},\ldots\}

Each structure :math:`p` contains parameters relevant to a particular
step in the sequence:

.. math:: p:=(p.M,p.N,\ldots)

If the sequence has just one member, a structure can be used directly,
without an enclosing cell array.

xQSim internal phase-space
~~~~~~~~~~~~~~~~~~~~~~~~~~

Although this is transparent to the user, each network in the sequence
transforms a matrix of quantum phase-space amplitudes:

.. math:: \bm{a}:=\left[\bm{\alpha},\bm{\beta}\right]_{j}=a_{ij}

The first index is the mode index from :math:`1,\ldots,2M`, where
indices from :math:`1,\ldots,M` indicate amplitudes equivalent to
:math:`\hat{a}_{i}`, and indices from :math:`M+1,\ldots,2M` are
amplitudes equivalent to :math:`\hat{a}_{i}^{\dagger}`. These quantum
amplitudes can be recycled in a sequence of network operations.

The second index is from :math:`1,\dots,p.ensembles(1)`, for ensemble
averaging using vector parallel processing. These transformations are
repeated :math:`p.ensembles(2)` times in a local loop, and
:math:`p.ensembles(3)` times nonlocally, with parallel loops. At least
one loop ensemble larger than :math:`1` is required to estimate errors.

User’s can vary between phase-space representations using :math:`method`
which corresponds to the :math:`\sigma`-ordering notation via
:math:`method=1` is equal to :math:`\sigma=0`, :math:`method=2` to
:math:`\sigma=1/2` and :math:`method=3` to :math:`\sigma=1`.

xQSim outputs
~~~~~~~~~~~~~

The output data is a nested cell array, whose length is the total
sequence length:

.. math:: data:=\{d_{1},d_{2},\ldots\}

At each step in the sequence, a data cell array :math:`d` of individual
quantum expectation values or graphs is generated, where:

.. math:: d:=\{g_{1},g_{2},\ldots\}

Here each graph :math:`g_{n}` is the output of the :math:`n`-th defined
observe function, described below. These are real, multidimensional
arrays of the data. They include averages calculated by the observe
functions, and error-bars generated by the :math:`qsim` code:

.. math:: g:=\left(g_{\ell j_{1}j_{2}\ldots j_{n},e}\right)

There is a standardized form of :math:`g`. The first index :math:`\ell`
is a line index, reserved for subsequent plotting software. The next
:math:`n` indices are a multidimensional data array with arbitrary
dimensionality. If :math:`cyc>1`, :math:`j_{1}` is the cycle index.
Other dimensions may correspond to a mode index or to a count number.
The last index :math:`e` is an error index, to address the data and
sampling error. This is also used to index the comparison or
experimental data, if it is available from the optional compare
functions.

xGraph inputs 
~~~~~~~~~~~~~~

If *xGraph* is used, it is called with the arguments (*input*, *data*).
Here :math:`input` is a cell array, a sequence of graphics structures.
It can be the same cell array used to define the simulation parameters.
However, the graphics parameters are a distinct set. The :math:`data` is
the output data from xQSim, or some combination of the output data in
more complex examples. One can run *xQSim* multiple times with different
parameters to show functional dependences. The purpose of xGraph is to
allow batch generation of many graphs from a multidimensional data
array.

Observations 
-------------

The *observe* functions are user-specified functions that calculate an
observable average and return it, given the phase-space amplitude matrix
:math:`\bm{a}`. Each *observe* function can have arbitrary output
dimensionality. Each can be assigned its own graphics parameters, and an
optional initialize function that initializes a given graph, specified
by the graph number :math:`n`. Parameters are passed to the observe
functions through the parameter structure, :math:`p`. Observe functions
are passed as handles, in a cell array, as @x2 (etc).

| Standard observe functions provided are:

.. container:: center

   ===== =========== =================================================
   Label Return type Description
   ===== =========== =================================================
   x2    vector      Mean x quadrature squared per channel
   p2    vector      Mean p quadrature squared per channel
   n     vector      Mean photon number per channel
   nm    vector      Mean number moments in sequence
   k     vector      Mean clicks per channel
   km    vector      Mean click moments in sequence
   km2   vector      Mean click moments over two sequential channels
   km3   vector      Mean click moments over three sequential channels
   kmsub vector      Mean subset of click moments per CO channels
   k1    vector      Click probability - single partition
   kn    array       Click probability - n-fold partition
   ===== =========== =================================================

List of observe functions
-------------------------

x2
~~

This computes the x quadrature moment per channel,
:math:`\left\langle \hat{x}_{k}^{2}\right\rangle`.

p2
~~

This computes the p quadrature moment per channel,
:math:`\left\langle \hat{p}_{k}^{2}\right\rangle`.

n
~

This computes the mean photon number per channel,
:math:`\left\langle \hat{a}_{k}^{\dagger}\hat{a}_{k}\right\rangle =\left\langle \hat{n}_{k}\right\rangle`.

nm
~~

This computes the mean photon number correlation over adjacent channels,
:math:`\left\langle \hat{n}_{1}\hat{n}_{2}\dots\hat{n}_{k}\right\rangle`.
The correlation order values are input as a cell array of index vectors,
:math:`p.O{n}=[k_{1},k_{2},..].`

k
~

This computes the mean clicks per channel, from the click projectors,
:math:`\left\langle \hat{\pi}_{k}\left(1\right)\right\rangle`.

km
~~

This computes the mean click correlation over a list of channels,
:math:`\left\langle \hat{\pi}_{1}\left(1\right)\hat{\pi}_{2}\left(1\right),\dots\hat{\pi}_{k}\left(1\right)\right\rangle`.
The correlation order values are input as a cell array of index vectors,
:math:`p.O{n}=[k_{1},k_{2},..].`

km2
~~~

This computes the mean click correlation over two channels,
:math:`\left\langle \hat{\pi}_{j}\left(1\right)\hat{\pi}_{k}\left(1\right)\right\rangle`,
where :math:`j<k`. The number of possible combinations follows the
binomial coefficient :math:`\binom{M}{n}`, where :math:`M` is the number
of modes and :math:`n` is the correlation order which is input as the
integer :math:`p.CO`.

km3
~~~

This computes the mean click correlation over three channels
:math:`\left\langle \hat{\pi}_{j}\left(1\right)\hat{\pi}_{k}\left(1\right)\hat{\pi}_{h}\left(1\right)\right\rangle`,
where :math:`j<k<h`. The number of possible combinations follows the
binomial coefficient :math:`\binom{M}{n}`, where :math:`M` is the number
of modes and :math:`n` is the correlation order which is input as the
integer :math:`p.CO`.

kmsub
~~~~~

This computes the first :math:`M-CO` mean click correlations from a
possible :math:`\binom{M}{n}`. This gives a more graphically appealing
output than :math:`km2` and :math:`km3` observables.

k1
~~

This calculates the total click probability in a partition of channels.
The partition indices can be input as a cell array giving the number of
channels, if the channels are numbered from :math:`1\ldots p.Part\{n\}`.

kn
~~

This calculates the total click probability in a multi-dimensional
partition of channels. The partition values can be input as a cell array
of vectors containing the number of channels, if the channels are
numbered sequentially from :math:`1\ldots p.Part\{1\}`. Otherwise, the
individual channel number vectors are input in a nested cell array of
vectors.

Comparisons
-----------

| The *compare* function is a user-specified function that evaluates a
  function and returns it. This is used for testing and also to input
  experimental data for comparisons. The comparisons may include error
  data, which can be zero for exact results. Comparisons are also
  plotted using *compare*. This generates additional comparison plots,
  as well as error totals that are converted into a :math:`\chi^{2}`-
  error estimate when there are statistical variances available.

.. container:: center

   ====== =========== =====================================
   Label  Return type Description
   ====== =========== =====================================
   x2c    vector      Mean x quadrature squared per channel
   p2c    vector      Mean p quadrature squared per channel
   nc     vector      Mean photon number per channel
   nmc    vector      Mean number moments in sequence
   kc     vector      Mean clicks per channel
   kmc    vector      Mean click moments in sequence
   km2c   vector      Mean clicks per two channels
   km3c   vector      Mean clicks per three channels
   kmsubc vector      Mean subset of clicks per CO channels
   k1c    vector      Click probability - single partition
   knc    array       Click probability - n-fold partition
   ====== =========== =====================================

   | 

In all analytic comparisons, there are two options:

-  an identity transmission matrix can be used with an arbitrary
   Gaussian input, uniform or non-uniform.

-  any unitary with a scaled transmission (:math:`t\le1`) can be used
   with a fully thermalized (:math:`eps=1`), uniform input.

x2c
~~~

This compares the analytic x quadrature moment per channel,
:math:`\left\langle \hat{x}^{2}\right\rangle`.

p2c
~~~

This compares the analytic p quadrature moment per channel,
:math:`\left\langle \hat{p}^{2}\right\rangle`.

nc
~~

This gives a comparison of photon numbers per channel.

nmc
~~~

This comparison of number moments uses the same input as **nm**.

kc
~~

This comparison of click probabilities per channel uses the same input
as **k**.

kmc
~~~

This comparison of click moments uses the same input as **km**.

km2c
~~~~

This comparison of all combinations of click probabilities over two
channels uses the same input as **km2**.

km3c
~~~~

This comparison of all combinations of click probabilities over three
channels uses the same input as **km3**.

kmsubc
~~~~~~

This comparison of a subset of all combinations of click probabilities
over sequential channels uses the same input as **kmsub**.

k1c
~~~

In this comparison the clicks are split into an n-fold partition, using
the same input as **k1**.

knc
~~~

In this comparison the clicks are split into an n-fold partition, using
the same input as **kn**.

Experimental data
=================

| This is generated by the Matlab program qcounts.m, which analyses
  experimental count data, from binary files in \*.bin. It generates
  individual Matlab data files for each observable and records the total
  number of valid counts, which are also saved in the data files. All
  experimental data should be on the Matlab path if comparisons are
  required.

.. container:: center

   +---------------+-----------------+----------------------------------+
   | Label         | Type            | Description                      |
   +===============+=================+==================================+
   | *@expmatrix*  | function handle | Experimental matrix, loaded in   |
   |               |                 | xQSim                            |
   +---------------+-----------------+----------------------------------+
   | *@expsqueeze* | function handle | Experimental squeezing data,     |
   |               |                 | loaded in xQSim                  |
   +---------------+-----------------+----------------------------------+
   | *expk.mat*    | file            | Experimental clicks per channel  |
   +---------------+-----------------+----------------------------------+
   | *expkm.mat*   | file            | Experimental :math:`K`-th order  |
   |               |                 | moment                           |
   +---------------+-----------------+----------------------------------+
   | *expk2m.mat*  | file            | All experimental second order    |
   |               |                 | click correlations               |
   +---------------+-----------------+----------------------------------+
   | *expk2ms.mat* | file            | Subset of experimental second    |
   |               |                 | order click correlations         |
   +---------------+-----------------+----------------------------------+
   | *expk3m.mat*  | file            | All experimental third order     |
   |               |                 | click correlations               |
   +---------------+-----------------+----------------------------------+
   | *expk3ms.mat* | file            | Subset of experimental third     |
   |               |                 | order click correlations         |
   +---------------+-----------------+----------------------------------+
   | *expk4ms.mat* | file            | Subset of experimental fourth    |
   |               |                 | order click correlations         |
   +---------------+-----------------+----------------------------------+
   | *expk1.mat*   | file            | Experimental single partition    |
   |               |                 | clicks                           |
   +---------------+-----------------+----------------------------------+
   | *expk2.mat*   | file            | Experimental two-fold partition  |
   |               |                 | clicks                           |
   +---------------+-----------------+----------------------------------+
   | *expk4.mat*   | file            | Experimental four-fold partition |
   |               |                 | clicks                           |
   +---------------+-----------------+----------------------------------+

Experimental comparisons
------------------------

| Using the *compare* function, experimental data is called from user
  specified functions which also sets error data to zero. Experimental
  error data is then calculated in xQSim and, following the
  :math:`\chi`-squared theory below, is converted into a
  :math:`\chi`-squared error estimate. Experimental comparison functions
  are located in qDATA.

.. container:: center

   +---------+--------+-------------------------------------------------+
   | Label   | Type   | Description                                     |
   +=========+========+=================================================+
   | expk    | vector | Experimental click probability - Clicks per     |
   |         |        | channel                                         |
   +---------+--------+-------------------------------------------------+
   | expkm   | vector | Experimental click probability - :math:`K`-th   |
   |         |        | order moment                                    |
   +---------+--------+-------------------------------------------------+
   | expk2m  | vector | Experimental click probability - All            |
   |         |        | combinations of clicks per two channels         |
   +---------+--------+-------------------------------------------------+
   | expk2ms | vector | Experimental click probability - Subset of      |
   |         |        | clicks per two channels                         |
   +---------+--------+-------------------------------------------------+
   | expk3m  | vector | Experimental click probability - All            |
   |         |        | combinations of clicks per three channels       |
   +---------+--------+-------------------------------------------------+
   | expk3ms | vector | Experimental click probability - Subset of      |
   |         |        | clicks per three channels                       |
   +---------+--------+-------------------------------------------------+
   | expk4ms | vector | Experimental click probability - Subset of      |
   |         |        | clicks per four channels                        |
   +---------+--------+-------------------------------------------------+
   | expk1   | vector | Experimental click probability - single         |
   |         |        | partition                                       |
   +---------+--------+-------------------------------------------------+
   | expk2   | matrix | Experimental click probability - two-fold       |
   |         |        | partition                                       |
   +---------+--------+-------------------------------------------------+
   | expk4   | matrix | Experimental click probability - four-fold      |
   |         |        | partition                                       |
   +---------+--------+-------------------------------------------------+

expk
----

In this comparison of experimental click probability per channel,
experimental data is loaded from *expk.mat*.

expkm
-----

In this comparison of experimental click probability per channel,
experimental data is loaded from *expkm.mat*.

expk2m
------

In this comparison of experimental click probabilities for all
combinations of two output channels, experimental data is loaded from
*expk2m.mat*.

expk2ms
-------

In this comparison of experimental click probabilities for a subset of
all two channel combinations, experimental data is loaded from
*expk2ms.mat*.

expk3m
------

In this comparison of experimental click probabilities for all
combinations of three output channels, experimental data is loaded from
*expk3m.mat*.

expk3ms
-------

In this comparison of experimental click probabilities for a subset of
all three channel combinations, experimental data is loaded from
*expk3ms.mat*.

expk4ms
-------

In this comparison of experimental click probabilities for a subset of
all four channel combinations, experimental data is loaded from
*expk4ms.mat*.

expk1
-----

In this comparison of experimental click probability for a single
partition of all channels, data is loaded from *expk1.mat*.

expk2
-----

In this comparison of experimental click probability for an equal
two-fold partition of all channels, data is loaded from *expk2.mat*.

expk4
-----

In this comparison of experimental click probability for four-fold
partition of all channels, data is loaded from *expk4.mat*.

Examples
========

The folder *xQSimExamples* contains a variety of examples for different
mode numbers, input states and observables. Individual tests can be
performed or all can be run using batch test scripts *xQSim_GBStestM.m*,
where :math:`M` varies between :math:`M=20,40,100` for different batch
tests.

The examples presented in this manual are slightly modified versions of
the examples given in *xQSimExamples*.

Squeezed thermalized state examples
-----------------------------------

Using the exact derivation of click projectors outlined in subsection.
`[subsec:Exact-click] <#subsec:Exact-click>`__ for the comparison
functions, special multimode test cases are used, in which all output
events are independent. This is obtainable either from having arbitrary
independent thermalized squeezed inputs and a diagonal transmission
matrix, or else by having a uniform, fully thermalized input together
with an arbitrary unitary transmission matrix.

Either of these cases lead to independent outputs in which each mode is
in a Gaussian state. The simplest case is for a uniform output in which
:math:`\left\langle \hat{\pi}\left(1\right)\right\rangle =p` is
constant. In this case, the probability of :math:`m` total clicks in
:math:`M` channels has a probability of:

.. math:: P\left(m\right)=\frac{M!p^{m}\left(1-p\right)^{M-m}}{m!\left(M-m\right)!}.

Two examples of this are given below.

Uniform squeezing
~~~~~~~~~~~~~~~~~

This example generates total count probabilities for the case of pure
squeezed state inputs with uniform squeezing
:math:`\boldsymbol{r}=[1,\dots,1]`. The transmission matrix is an
:math:`N\times M` identity matrix with :math:`M=N=20` and a transmission
coefficient of :math:`t=0.5`.

In this case, the :math:`\chi^{2}` statistical test outputs give
:math:`\chi^{2}/k\approx1\pm0.3` and the :math:`Z`-statistic gives
:math:`Z\approx1\pm2`. This indicates that the statistical test is
satisfied.

.. container:: center

 

.. container:: float

   .. container:: centering

      |image|\ |image1|

Thermal state
~~~~~~~~~~~~~

This example generates total count probabilities for the case of thermal
state inputs with squeezing parameter :math:`\boldsymbol{r}=[1,\dots,1]`
and :math:`\epsilon=1`. The transmission matrix is an :math:`N\times M`
Haar random unitary with :math:`M=N=100` and a transmission coefficient
of :math:`t=0.5`.

:math:`\chi^{2}` statistical test outputs give
:math:`\chi^{2}/k\approx1\pm0.4` for :math:`k=45` valid bins whilst the
:math:`Z`-statistic gives :math:`Z\approx1.5\pm2`.

.. container:: center

 

.. container:: float

   .. container:: centering

      |image2|\ |image3|

Multidimensional binning
------------------------

This example generates output GCPs in two and four dimensions for the
case of non-uniform squeezed inputs. The transmission matrix is an
:math:`N\times M` identity matrix with :math:`M=N=40` and a transmission
coefficient of :math:`t=0.5`.

For simulations with :math:`d>1`, xGraph generates four output plots;
two 3D surface plots and two 2D plots. When :math:`d=2`, one surface
plot is the full two-dimensional distribution, whilst the other is the
difference comparison plot. For :math:`d>2` the surface plots are then
two-dimensional planar slices of, by default, grouped counts
:math:`m_{1},m_{2}` although this can be changed. Standard 2D plot
outputs are always one-dimensional slices of surface plots.

Two-dimensional comparisons give :math:`\chi^{2}` statistical test
outputs of :math:`\chi^{2}/k\approx1\pm0.5` for :math:`k=169` valid bins
whilst the :math:`Z`-statistic gives :math:`Z\approx0.7\pm2`.
Four-dimensional comparisons give :math:`\chi^{2}/k\approx1\pm0.5` for
:math:`k=2083` valid bins and :math:`Z\approx1.4\pm2`.

.. container:: center

 

.. container:: float

   .. container:: centering

      |image4|\ |image5|

.. container:: float

   .. container:: centering

      |image6|\ |image7|

Phase-space comparisons
-----------------------

This example generates intensity correlation moments,
:math:`\left\langle \hat{n}'_{1}\dots\hat{n}'_{j}\right\rangle`, of
orders :math:`1\rightarrow5` for non-uniform thermalized squeezed state
inputs in the positive-P, Wigner and Q phase-space representations with
:math:`\epsilon=0.5`. The transmission matrix is an :math:`N\times M`
identity matrix with :math:`M=N=20` and a transmission coefficient of
:math:`t=0.5`.

Changing between representations is simple and can be performed on one
script as shown below. However, Wigner and Q representations can only be
used to compute observables with photon number outputs or quadrature
operator moments.

.. container:: center

 

.. container:: float

   .. container:: centering

      |image8|

   .. container:: centering

      |image9|

   |image10|

Experimental examples
---------------------

This subsection contains examples for simulations using experimental
data from the :math:`100`-mode implementation of Zhong et al
:raw-latex:`\cite{Raw100,zhong2020quantum}`. Although multiple examples
are given in the *xQSimExamples* folder, we focus on generating
comparisons of higher-order click correlations and random permutations
of binary patterns in this manual.

High-order correlations
~~~~~~~~~~~~~~~~~~~~~~~

This example generates comparisons of click correlation moments of first
and second order which are defined as

.. math:: \left\langle \hat{\pi}_{j}(1)\right\rangle

.. math:: \left\langle \hat{\pi}_{j}(1)\hat{\pi}_{k}(1)\right\rangle .

Comparisons can be obtained for all possible combinations of output
modes, which follows the binomial coefficient :math:`\binom{M}{n}`, or
for a subset of these combinations. The subset comparisons are
preferable for graphing, whilst the full comparison of output modes is
preferable for statistical tests to ensure all possible correlations are
observed. Not observing all correlations will alter the statistical test
outputs as there are fewer valid bins.

Inputs are thermalized squeezed states with decoherence coefficient
:math:`eps=0.0932` and transmission :math:`t=1.0235`. Simulations were
performed for :math:`1.44\times10^{7}` ensembles. First-order
correlations have statistical test outputs of
:math:`\chi^{2}/k\approx5.25\times10^{3}` and :math:`Z\approx347`, for
:math:`k=100`, whilst second-order marginals give
:math:`\chi^{2}/k\approx4.99\times10^{3}` and
:math:`Z\approx2.4\times10^{3}`, for :math:`k=4950`.

.. container:: center

 

.. container:: float

   .. container:: centering

      |image11|\ |image12|

Random permutations
~~~~~~~~~~~~~~~~~~~

This example generates comparisons of two-dimensional GCPs for binary
patterns that have been randomly permuted. Inputs are thermalized
squeezed states with decoherence coefficient :math:`eps=0.0932` and
transmission :math:`t=1.0235`. Data for three random permutations from
this experiment are available in the folder *xQSimGBSExperiments*,
however more can be readily obtained.

Permutations are input through the parameter *p.permute*, which is
assumed to be a :math:`1\times M` row vector, and are applied to the
transmission matrix, changing the row order according to the mode
ordering of the permutation. User’s can either manually permute output
modes, e.g. :math:`p.permute=[15,8,44,\dots]`, or use permutations
generated from data extraction algorithms which are loaded from relevant
.mat files by the function *xqpermutation* (see subsection.
`[subsec:Data-extraction] <#subsec:Data-extraction>`__). Note, manual
permutation vectors are only applied to the transmission matrix rows,
not the binary data which must be permuted before being binned.

Simulations can then be performed, with total count and click
correlations unaffected by the permutation. Since each permutation
produces comparisons of different correlations, each test will output
different :math:`\chi^{2}` and :math:`Z`-statistic results as well as
normalized difference graphs. An example of this is given in the below
figure.

.. container:: center

 

.. container:: float

   .. container:: centering

      |image13|\ |image14|

xQSim reference 
================

**This section gives a reference guide to the xQSim parameters and
functions.**

Included programs
-----------------

The package provided has six parts:

#. **xQSimCode.** This contains all the main quantum simulation codes,
   from observable and comparison functions to quantum phase-space
   sample generating functions.

#. **xQSimExamples.** This has the scripts used to simulate experiments
   for comparisons, as well as scripts used for testing.

#. **xQSimData.** This has scripts used for simulating data from recent
   Gaussian boson sampling experiments.

#. **xQSimDocumentation.** This provides the documentation, including
   this report and a separate manual for the graphics program *xGraph*.

#. **xGraph.** This contains a multidimensional graphics program which
   is also used in the stochastic differential equation software package
   *xSPDE*.

#. **xQSimGBSExperiments.** This has recent public experimental data
   from Refs. :raw-latex:`\cite{zhong2020quantum,Zhong2021Phase}`, and
   data extraction codes for reference purposes.

xQSim function call
-------------------

The simulation function takes an input of parameter structures that
define a sequence of networks. Each network in the sequence can be
repeated, with recycling of the amplitudes, which are then combined with
new squeezed or coherent inputs. Any input parameters or functions that
are omitted are given appropriate default values.

Simulations carried out by the code are performed by other specialized
internal functions. Input parameters come from an **input** cell array
of structures, while output is saved in a **data** array, and optionally
in a file. During the simulation, global averages and error-bars are
calculated for sampling errors. When completed, timing and errors are
printed.

The *xQSim* function call syntax is: *[error,data,output] =
xQSim(input);*

The input data includes parameters and methods, but with an open
architecture for extensibility. Most functions are modular and
replaceable. This is as easy as defining a new function handle to
replace the default value. The code folder includes examples of how
these are written. All output observables are divided up into a cell
array of data graphs, generated in parallel.

To explain this in full detail,

-  Simulation parameters are stored in the **input** cell array.

-  This describes a sequence of parameter structures, so that
   **input={p1,p2,...}**.

-  Each structure **p1,p2,...** generates an output which is the input
   of the next.

-  The main simulation function is called using **xQSim(input).**

-  The errors and integration time are returned in the **error** vector

-  Averages are recorded sequentially in the **data** cell array.

-  Parameters including defaults are returned in the **output** cell
   array.

The sequence *input* defines a sequence of individual simulations, with
parameters that specify the simulation functions and give the equations
and observables. If there is only one simulation, just one data
structure is needed, without a cell array. In addition, xQSim can
generates graphs with a companion graphics program, xGraph.

Parameters and functions
------------------------

The xQSim input objects include parameters and functions. Many xQSim
functions are modular and replaceable, through defining a new function
handle to replace the default value.

There are standard conventions used throughout:

-  All arguments in square brackets are optional, but may be needed only
   in specific cases.

-  The last argument, *p,* is the parameter structure.

| The user-definable functions, input and output field dimensions and
  calling arguments are:

.. container:: center

   +----------------------+----------------------+----------------------+
   | Label                | Arguments            | Output dimensions    |
   +======================+======================+======================+
   | *a=qgen*             | *(a,p):              | *:math:`             |
   |                      | :                    | a=(2M\times S_{1})`* |
   |                      | math:`a=(2M\times S_ |                      |
   |                      | {1})`,   p=[struct]* |                      |
   +----------------------+----------------------+----------------------+
   | *pe                  | ~                    | Arbitrary:           |
   | rmute=xqpermutation* |                      | :math:`1\times M`    |
   +----------------------+----------------------+----------------------+
   | *o=observe{n}*       | *(a,p):              | Arbitrary:           |
   |                      | :                    | :ma                  |
   |                      | math:`a=(2M\times S_ | th:`m_{1}\times m_{2 |
   |                      | {1})`,   p=[struct]* | }\ldots\times m_{n}` |
   +----------------------+----------------------+----------------------+
   | *c=compare{n}*       | *:math:              | Match observe:       |
   |                      | `(p)`,   p=[struct]* | :ma                  |
   |                      |                      | th:`m_{1}\times m_{2 |
   |                      |                      | }\ldots\times m_{n}` |
   +----------------------+----------------------+----------------------+

   | 

Notes

-  **qgen** **has a default, namely :math:`xqgen`, which can be user
   modified**

-  **qgen input amplitudes are used for recycling. If this is not
   required, just use :math:`(\sim,p):`**

-  **data outputs to xGraph include two extra dimensions,
   :math:`m_{l}\times m_{1}\times m_{2}\ldots\times m_{n}\times m_{e}`**

-  **The first graphics :math:`m_{l}` dimension is reserved for plotting
   multiple lines on graphs**

-  **Obtaining multiple lines requires modifying the output data file
   before xGraph**

-  **The :math:`m_{e}` dimension is used for error bars. Here
   :math:`m_{e}=3` stores the sampling error bars**

Customization guide
-------------------

To define your own stochastic generation function, include in the input
the line:

.. container:: center

Next, include anywhere on your Matlab path the function definition, for
example:

.. container:: center

|  
| Similarly, to define your own observe function for (say) data graph
  :math:`6`, include in the input the line:

.. container:: center

Next, include anywhere on your Matlab path the function definition, for
example:

.. container:: center

|  
| To define your own comparison function for the same graph, include in
  the input the line:

.. container:: center

Next, include anywhere on your Matlab path the compare definition, for
example:

.. container:: center

Hints
-----

-  When using xQSim, it is a good idea to first run the batch test
   script, xQSimtest.m.

-  xQSimtest.m tests your parallel toolbox installation. If you have no
   license for this, omit the third ensemble setting.

-  To create a script, it is often easiest to start with an existing
   script with similar requirements: see Examples folder.

-  Graphics parameters can also be included in the parameter structure
   :math:`\mathbf{p}`, either before or after calling :math:`qcpsim`, to
   modify graphs.

-  Comparison functions can be included to compare with analytic or
   experimental results.

-  A full list of functionality is listed below.

The input data, here labeled :math:`input`, is a sequence of parameter
structures that are labeled :math:`p`. All of the input parameters and
data are later passed to the :math:`xgraph` function. The input data can
be numbers, vectors, strings, functions and cell arrays. These are lists
of data enclosed in curly brackets, :math:`\{\}`. All xQSim metadata has
preferred values, so only changes from the preferences need to be input.
The resulting combined input including preferred values, is stored
internally as a sequence of structures in a cell array to describe the
simulation sequence.

Simulation metadata, including all preferred default values that were
used in a particular simulation, is also stored in the xQSim output
files. This is done in the Matlab :math:`.mat` format, for simplicity so
the entire simulation can be easily reconstructed or changed.

Some conventions are used to simplify inputs, as follows:

-  **Most input data has default values**

-  **Vector inputs of numbers are enclosed in square brackets, [...].**

-  **Where multiple inputs of strings, functions or vectors are needed
   they should be enclosed in curly brackets, {...}, to create a cell
   array.**

-  **Vector or cell array inputs with only one member don’t require
   brackets.**

-  **Incomplete vector or array inputs are completed with the last
   default or input value.**

-  **Default parameters are checked by inspecting the outputs, or
   setting verbose = 2.**

In the output data arrays, the last index has :math:`m_{e}=1` for the
averages. The first error field, :math:`m_{e}=2`, is reserved for any
systematic errors like step-sizes. The last error field, :math:`m_{e}=3`
is used for storing one standard deviation error-bar estimates due to
computational sampling errors.

Parameter table
---------------

Simulation parameters are stored in a parameter structure which is
passed to the :math:`xsim` program. Inputs have default values, which
are user-modifiable through the *xpreferences* function. Defaults can be
checked by including the input :math:`verbose=2`\ *.* All the inputs are
part of a structure passed to xQSim. If a cell array of multiple
structures are input, these are executed in sequence, with the output of
the first simulation passed to the second, then the third, and so on.

.. container:: center

   +-------------+-----------------+-----------------+-----------------+
   | Label       | Type            | Default         | Description     |
   +=============+=================+=================+=================+
   | *deco*      | string          | ”               | Decoherence     |
   |             |                 |                 | factors used    |
   |             |                 |                 | for             |
   |             |                 |                 | optimization    |
   +-------------+-----------------+-----------------+-----------------+
   | *bits*      | integer         | None            | Number of bits  |
   |             |                 |                 | used for data   |
   |             |                 |                 | extraction      |
   +-------------+-----------------+-----------------+-----------------+
   | CO          | integer         | None            | Correlation     |
   |             |                 |                 | order           |
   +-------------+-----------------+-----------------+-----------------+
   | *compare*   | function        | []              | Optional        |
   |             | handles         |                 | comparison      |
   |             |                 |                 | functions       |
   +-------------+-----------------+-----------------+-----------------+
   | *counts*    | integer         | 0               | Total           |
   |             |                 |                 | experimental    |
   |             |                 |                 | counts for      |
   |             |                 |                 | :               |
   |             |                 |                 | math:`\chi^{2}` |
   |             |                 |                 | tests           |
   +-------------+-----------------+-----------------+-----------------+
   | *cutoff*    | real            | -1.e100         | Lower cutoff    |
   |             |                 |                 | for graphs and  |
   |             |                 |                 | :               |
   |             |                 |                 | math:`\chi^{2}` |
   +-------------+-----------------+-----------------+-----------------+
   | *cyc*       | integer         | 1               | Number of       |
   |             |                 |                 | cycles of the   |
   |             |                 |                 | network         |
   +-------------+-----------------+-----------------+-----------------+
   | *ensembles* | vector          | [1,1,1]         | Size of vector, |
   |             |                 |                 | serial,         |
   |             |                 |                 | parallel        |
   |             |                 |                 | ensemble        |
   +-------------+-----------------+-----------------+-----------------+
   | *eps*       | vector          | 0               | An              |
   |             |                 |                 | n-dimensional   |
   |             |                 |                 | decoherence     |
   |             |                 |                 | factor          |
   +-------------+-----------------+-----------------+-----------------+
   | M           | integer         | 1               | Total matrix    |
   |             |                 |                 | size            |
   +-------------+-----------------+-----------------+-----------------+
   | *matrix*    | matrix function | Identity        | An              |
   |             |                 |                 | :m              |
   |             |                 |                 | ath:`M\times M` |
   |             |                 |                 | transfer matrix |
   |             |                 |                 | function        |
   +-------------+-----------------+-----------------+-----------------+
   | *method*    | integer         | 1               | Phase-space     |
   |             |                 |                 | method:         |
   |             |                 |                 | :math:`m=1,2,3` |
   +-------------+-----------------+-----------------+-----------------+
   | *mincount*  | integer         | 0               | Minimum count   |
   |             |                 |                 | for             |
   |             |                 |                 | :               |
   |             |                 |                 | math:`\chi^{2}` |
   |             |                 |                 | tests           |
   +-------------+-----------------+-----------------+-----------------+
   | N           | integer         | 1               | Number of       |
   |             |                 |                 | excited input   |
   |             |                 |                 | modes           |
   +-------------+-----------------+-----------------+-----------------+
   | *name*      | character       | ”               | Name of         |
   |             |                 |                 | simulation      |
   +-------------+-----------------+-----------------+-----------------+
   | O           | vector          | None            | Vector of       |
   |             |                 |                 | various         |
   |             |                 |                 | correlation     |
   |             |                 |                 | orders          |
   +-------------+-----------------+-----------------+-----------------+
   | *observe*   | function        | :math:          | Observable      |
   |             | handles         | `\{@(a,p)\,a\}` | functions       |
   +-------------+-----------------+-----------------+-----------------+
   | *permute*   | integer vector  | :math:`[        | Random          |
   |             |                 | 1,2,3,\dots,M]` | permutation of  |
   |             |                 |                 | outputs         |
   +-------------+-----------------+-----------------+-----------------+
   | *pnames*    | array of        | {’+P ’,’W ’,’Q  | Names of        |
   |             | characters      | ’}              | phase-space     |
   |             |                 |                 | methods         |
   +-------------+-----------------+-----------------+-----------------+
   | *qgen*      | function handle | :math:`@xqgen`  | Stochastic      |
   |             |                 |                 | generation code |
   +-------------+-----------------+-----------------+-----------------+
   | *r*         | vector or       | 0               | An              |
   |             | function        |                 | n-dimensional   |
   |             |                 |                 | squeezing       |
   |             |                 |                 | vector          |
   +-------------+-----------------+-----------------+-----------------+
   | re          | vector          | 1               | An              |
   |             |                 |                 | n-dimensional   |
   |             |                 |                 | recycling       |
   |             |                 |                 | factor          |
   +-------------+-----------------+-----------------+-----------------+
   | *t*         | vector          | 1               | An              |
   |             |                 |                 | n-dimensional   |
   |             |                 |                 | transmission    |
   |             |                 |                 | factor          |
   +-------------+-----------------+-----------------+-----------------+
   | *Tname*     | unitary name    | matrix(0)       | Name of         |
   |             |                 |                 | transmission    |
   |             |                 |                 | matrix          |
   +-------------+-----------------+-----------------+-----------------+
   | *verbose*   | integer         | 0               | Flag for        |
   |             |                 |                 | printing        |
   |             |                 |                 | verbosity       |
   |             |                 |                 | level: 0,1,2    |
   +-------------+-----------------+-----------------+-----------------+

Parameter reference
-------------------

The following parameters can be applied to each member of the simulation
sequence. For single-input, single-pass GBS experiments, they are only
specified once.

bits
~~~~

Default:
   None

Integer used to define the bit-type encoding of experimental binary data
files. Only used for integrated data extraction codes.

-  p.bits

compare
~~~~~~~

Default:
   []

Cell array of function handles to generate the comparison data. A large
number of functions equivalent to common hermitian operators are
available for analytically known cases..

-  p.compare = {@function,..}

CO
~~

Default:
   None

Used to define the correlation order for calculating click correlation
moments or marginal probabilities of output distribution.

-  :math:`p.CO`

counts
~~~~~~

Default:
   0

Used to define the total counts for calculating count numbers and
minimum count cutoffs when there is experimental data on experimental
count probabilities.

-  :math:`p.counts>0`

cutoff
~~~~~~

Default:
   -1E-100

Used to define a lower cutoff, especially for probability data, where a
small positive value, e.g. :math:`10^{-7}`, should be used. This is
useful for log graphs and :math:`\chi^{2}` fits.

-  :math:`p.cutoff`

cyc
~~~

Default:
   1

Number of cycles of the network simulated.

-  p.cyc >0

deco
~~~~

Default:
   ’ ’

String used to output deocherence factors :math:`eps` and :math:`t`
during optimization. Only needs to be used if Matlabs *fminsearch* is
performing optimization.

-  p.deco

ensembles
~~~~~~~~~

Default:
   [1,1,1]

Number of ensembles used in simulations. The first is the local vector
ensemble. The second is the number of serial repeats. The third is the
number or parallel repeats. Note that serial and parallel repeats are
used for sampling error estimation.

-  p.name = [ens1,ens2,ens3]

eps
~~~

Default:
   0

This gives a real decoherence vector that is input. It is expected to be
of length at least :math:`p.N`. If smaller, it will be expanded to
length :math:`p.N`. The values should such that :math:`0\le p.eps\le1`.

-  p.eps

M
~

Default:
   1

Total number of input and/or output modes to the network.

-  p.M >0

matrix
~~~~~~

Default:
   @Identity

Function handle to generate the linear network matrix. Both Identity and
random Unitary matrices are supplied. It can also be just an
:math:`M\times M` complex matrix, for small test matrices entered
inline.

-  p.matrix = @function

method
~~~~~~

Default:
   1

The phase-space method, where 1 = generalized P-representation, 2 =
Wigner representation, 3 = Husimi (Q) representation

-  p.method > 0

mincount
~~~~~~~~

Default:
   0

Used to set a lower bound on calculations for chi-square fits, when
there is experimental data on experimental count probabilities. A
typical value here is :math:`10`.

-  :math:`p.mincount>0`

.. _n-1:

N
~

Default:
   1

Number of input modes excited, less than or equal :math:`M`

-  p.N >0

-  p.M >0

name
~~~~

Default:
   ’ ’

Name used to label simulation, usually corresponding to the equation or
problem solved, and will be passed to the xGraph program if it is used.

-  p.name = ’your project name’

O
~

Default:
   None

Used to define a vector of correlation orders to simulate mean click or
photon number correlations over adjacent channels.

-  :math:`p.O`

observe
~~~~~~~

Default:
   {@(a,p) mean(real(a),2)}

Cell array of function handles to generate the observable phase-space
averages. A large number of functions equivalent to commonly used
hermitian operators are available.

-  p.observe = {@function,..}

permute
~~~~~~~

Default:
   :math:`[1,2,3,\dots,M]`

Random permutation vector of size :math:`1\times M` obtained either
manually or via a data extraction output which is applied to rows of the
transmission matrix for phase-space simulations.

-  p.permute = xqpermutation

pnames
~~~~~~

Default:
   {’+P ’,’W ’,’Q ’}

Cell vector of names used to label the phase-space representation, to
allow future expansion or changes. Normally is not changed from default
and can be omitted.

-  p.pnames = {’your favorite method’}

qgen
~~~~

Default:
   @qgen

Name of network quantum noise function. The default qgen function is
used for GBS, and in this case, just omit :math:`qgen`.

-  p.qgen = @yourgenerator

r
~

Default:
   0

This gives a real squeezing vector that is input. It is expected to be
of length at least :math:`p.N`. If smaller, it will be expanded to
length :math:`p.N`. The entries with index greater than :math:`p.N` are
set to zero. Can be replaced by a function call for large quantities of
data.

-  p.r

re
~~

Default:
   0

This gives a real recycling amplitude. It is expected to be of length
:math:`p.M`. If smaller, it will be expanded to length :math:`p.M`. The
entries with index greater than :math:`p.M` are set to zero. This allows
previous amplitudes to be recycled.

-  :math:`p.re\le1`

t
~

Default:
   1

This gives a real transmission vector that is input. It is expected to
be of length :math:`p.M`. If smaller, it will be expanded to length
:math:`p.M`. The entries with index greater than :math:`p.M` are set to
zero. This allows corrections to be made to the measured transmission
matrix.

-  :math:`p.t\le1`

Tname
~~~~~

Default:
   matrix(0)

Name used to label type of network matrix. Usually it is returned by the
matrix function to give the default name. However, other matrix names
can be entered here.

-  p.Tname = ’your transmission matrix name’

verbose
~~~~~~~

Default:
   0

Print flag for output information while running xQSim. If “verbose = 0“,
most output is suppressed, while “verbose = 1“ displays a progress
report, and “verbose = 2“ also generates a readable summary of the
parameters as a record.

-  p.verbose >= 0

xGraph reference
================

The graphics function provided is a general purpose multidimensional
batch graphics code, xGraph, which can be called when xQSim is finished.
The results are graphed and output if required. Alternatively, xGraph
can be replaced by another graphics code, or it can be used to process
the data generated by xQSim at a later time.

The program is described elsewhere, but the documentation is replicated
here for users who wish to use it. The *xGraph* function call syntax is:

-  **xgraph (data [,input])**

This takes simulation *data* and *input* cell arrays with graphics
parameters, then plots graphs. The *data* should have as many cells as
there are *input* cells, for sequences. The data can include
comparisons, either analytic or experimental, and error-bars for both
the simulations and the comparisons, since either may have sampling or
other errors.

If *data = ’filename.h5’* or *’filename.mat’*, the specified file is
read both for *input* and *data*. Here *.h5* indicates an HDF5 file, and
*.mat* indicates a Matlab file.

When the *data* input is a filename, parameters in the file can be
replaced by new *input* parameters that are specified. Any stored
*input* parameters in the file are overwritten when graphs are
generated. This allows graphs of data to be modified retrospectively, if
the simulation takes too long to be run again in a reasonable timeframe.

Parameter and data structures
-----------------------------

This is a batch graphics function, intended to process quantities of
graphics data in sequence, input as a cell array of multi-dimensional
data. Theoretical and/or experimental data is passed to the graphics
program, including the complete *data* cell array and a cell array of
graphics parameters for plotting each graph. For a sequence of one
member, the enclosing cell array can be omitted.

To explain xGraph in full detail,

-  Data to be graphed are recorded sequentially in a cell array, with
   *data={d1,d2,...}*.

-  Graphics parameters including defaults are given in the *input* cell
   array.

-  This describes a sequence of graph parameters, so that
   *input={p1,p2,...}*.

-  For a one member sequence, a dataset and parameter structure can be
   used on its own.

-  Each dataset and parameter structure describes a set of graphs.

The data input to *xGraph* can either come from a file, or from data
generated directly with *x*\ QSim. The main graphics data is a nested
cell array. It contains several numerical graphics arrays. Each defines
one independent set of averaged data, the observed data averages, stored
in a cell array indexed as :math:`data\{s\}\{n\}(\ell,\mathbf{j},c)`. To
graph these also requires a corresponding cell array of structures of
graphics parameters.

The output is unlimited, apart from memory limits. The program also
generates error comparisons and chi-squared values if required. The data
structure for input is as follows:

#. The *input* is a cell array of parameter structures, which can be
   collapsed to one structure

#. The input *data* is a cell array of *datasets,* which can be
   collapsed to a single dataset

#. Each *dataset* is a cell array of multidimensional *graphs*, with
   arbitrary dimensionality.

#. The first or *line* index of each graph array allows multiple lines,
   with different line-styles

#. The last or *check* index of each graph array is optionally used for
   error and comparison fields.

#. Each *graph* array can generate multiple graphic plots, as defined by
   the parameters.

.. _comparisons-1:

Comparisons
~~~~~~~~~~~

For every type of observation, the observe function can be accompanied
by a comparison function, *compare(p)*. This generates a vector of
analytic solutions or experimental data which is compared to the
stochastic results. Results are plotted as additional lines on the
two-dimensional graphical outputs, and comparison differences can be
graphed in any dimension.

Comparisons are possible for either moments or probabilities, and can be
input in any number of dimensions. When there are error estimates, a
chi-squared test is carried out to determine if the difference is within
the expected step-size and sampling error bars. If the comparison has
errors, for example from experimental data, the chi-squared test will
include the experimental errors.

Comparison data can be added to the graphics files from any source. It
must match the corresponding space-time lattice or probability bins that
are in the graphed data. Note that the *compare* functions are specified
during the simulation. The graphics code does not generate comparison
data, as it is dedicated to graphics, not to generating data.

.. _parameter-table-1:

Parameter table
---------------

The complete cell array of the simulation data is passed to the *xGraph*
program, along with graphics parameters for each observable, to create
an extended graphics data structure. Graphics parameters have default
values which are user-modifiable by editing the *xgpreferences*
function.

Some input parameters are global parameters for all graphs. However,
most *xGraph* parameters are cell arrays indexed by graph index. These
graphics parameters are individually set for each output that is
plotted, using the cell index :math:`\{n\}` in a curly bracket. If
present they replace the global parameters like labels.

If a graph index is omitted, and the parameter is not a nested array,
the program will use the same value for all graphs. The *axes*,
*glabels, legends, lines, logs,* and *xfunctions* of each graph are
nested cell arrays, as there can be any number of lines and axis
dimensions. In the case of the *logs* switch, the observable axis is
treated as an extra dimension.

The plotted result can be an arbitrary function of the generated average
data, by using the optional input *gfunction.* If this is omitted, the
generated average data that is input is plotted.

Comparisons are plotted if present in the input data indexed by the last
or check index :math:`c`, with *:math:`c>errors`*, where
*:math:`errors=3`* is the usual maximum value.

| A table of the graphics parameters is given below.

+-----------------+------------------------+------------------------+
| Label           | Default value          | Description            |
+=================+========================+========================+
| *axes{n}*       | {0,..}                 | Points plotted for     |
|                 |                        | each axis              |
+-----------------+------------------------+------------------------+
| *chisqplot{n}*  | 0                      | Chi-square plot        |
|                 |                        | options                |
+-----------------+------------------------+------------------------+
| *cutoff*        | 1.e-12                 | Global lower cutoff    |
|                 |                        | for chi-squares        |
+-----------------+------------------------+------------------------+
| *cutoffs{n}*    | *cutoff*               | Probability cutoff for |
|                 |                        | n-th graph             |
+-----------------+------------------------+------------------------+
| *diffplot{n}*   | 0                      | Comparison difference  |
|                 |                        | plot options           |
+-----------------+------------------------+------------------------+
| *errors*        | 0                      | Index of last error    |
|                 |                        | field in *data*        |
+-----------------+------------------------+------------------------+
| *esample{n}*    | 1                      | Size and type of       |
|                 |                        | sampling error-bar     |
+-----------------+------------------------+------------------------+
| *font{n}*       | 18                     | Font size for graph    |
|                 |                        | labels                 |
+-----------------+------------------------+------------------------+
| *gfunction{n}*  | @(d,~) d{n}            | Functions of graphics  |
|                 |                        | data                   |
+-----------------+------------------------+------------------------+
| *glabels{n}*    | *{’t’ ,’x’ ,’y’ ,’z’}* | Graph-specific axis    |
|                 |                        | labels                 |
+-----------------+------------------------+------------------------+
| *graphs*        | :math:`[1:max]`        | Vector of all the      |
|                 |                        | required graphs        |
+-----------------+------------------------+------------------------+
| *gsqplot{n}*    | 0                      | G-square (likelihood)  |
|                 |                        | plot options           |
+-----------------+------------------------+------------------------+
| *headers{n}*    | ”                      | Graph headers          |
+-----------------+------------------------+------------------------+
| *images{n}*     | 0                      | Number of movie images |
+-----------------+------------------------+------------------------+
| *imagetype{n}*  | 0                      | Type of 3D image       |
+-----------------+------------------------+------------------------+
| *legends{n}*    | {’label1’,..}          | Legends for multi-line |
|                 |                        | graphs                 |
+-----------------+------------------------+------------------------+
| *limits{n}*     | *                      | Axis limits, first     |
|                 | {[lc1,uc1],[lc2,uc2]}* | lower then upper       |
+-----------------+------------------------+------------------------+
| *linestyle{n}*  | *{’-’,..}*             | Line styles for        |
|                 |                        | multiline 2D graphs    |
+-----------------+------------------------+------------------------+
| *linewidth{n}*  | *0.5*                  | Line width for 2D      |
|                 |                        | graphs (in points)     |
+-----------------+------------------------+------------------------+
| *logs{n}*       | {0,..}                 | Axis logarithmic       |
|                 |                        | switch: :math:`0`      |
|                 |                        | linear, :math:`1` log  |
+-----------------+------------------------+------------------------+
| *minbar{n}*     | *0.01*                 | Minimum relative       |
|                 |                        | error-bar              |
+-----------------+------------------------+------------------------+
| *mincount*      | 10                     | Global counts for      |
|                 |                        | chi-square cutoffs     |
+-----------------+------------------------+------------------------+
| *name*          | ”                      | Global graph header    |
+-----------------+------------------------+------------------------+
| *olabels{n}*    | *’a_1’*                | Observable labels      |
+-----------------+------------------------+------------------------+
| *pdimension{n}* | 3                      | Maximum plot           |
|                 |                        | dimensions             |
+-----------------+------------------------+------------------------+
| *saveeps*       | 0                      | Switch, set to 1 to    |
|                 |                        | save eps files         |
+-----------------+------------------------+------------------------+
| *savefig*       | 0                      | Switch, set to 1 to    |
|                 |                        | save figure files      |
+-----------------+------------------------+------------------------+
| *scale{n}*      | 1                      | Scaling: Counts/       |
|                 |                        | probability density    |
+-----------------+------------------------+------------------------+
| *transverse{n}* | 0                      | Number of transverse   |
|                 |                        | plots                  |
+-----------------+------------------------+------------------------+
| *xfunctions{n}* | *{@(t,~) t,@(x,~)      | Axis transformations   |
|                 | x,..}*                 |                        |
+-----------------+------------------------+------------------------+
| *verbose*       | 0                      | 0 for brief, 1 for     |
|                 |                        | informative, 2 for     |
|                 |                        | full output            |
+-----------------+------------------------+------------------------+
| *xlabels*       | *{’t’ ,’x’ ,’y’        | Global axis labels     |
|                 | ,’z’...}*              |                        |
+-----------------+------------------------+------------------------+
| *octave*        | 0                      | 0 for Matlab, 1 for    |
|                 |                        | octave environment     |
+-----------------+------------------------+------------------------+

-  There are up to 6 types of input data, with errors and comparisons,
   indexed by the last index. The original mean data always has *c =1*.
   If there are no errors or comparisons, one graph is plotted for each
   dimensional reduction.

-  The data has up to two error bars (I and II), and optional
   comparisons with up to two error bars.

-  Type I errors labeled *:math:`c=2`* have standard vertical error
   bars. Type II errors labeled *:math:`c=3`*, which are usually
   standard deviation errors from sampling, have two solid lines.

-  If *esample* = -1\ *,* the error bars are combined and the RMS errors
   are plotted as a single error bar.

-  If *:math:`diffplot>0`,* differences are plotted as unnormalized
   (*:math:`diffplot=1`)*, or normalized (*:math:`diffplot=2`)* by the
   total RMS errors. If :math:`diffplot=3`, raw comparison data is
   plotted.

-  When differences are plotted, the total comparison errors have type I
   error bars while total simulation errors have type II errors with
   parallel lines, in order to distinguish them.

A detailed description of each parameter is listed in Sec
(`[sec:Parameter-reference] <#sec:Parameter-reference>`__).

Example
-------

A simple example of data and input parameters, but without errors or
comparisons is as follows

.. container:: center

.. container:: float

   |image15|\ |image16|

Note that in this case the default setting of *p.errors=0* is used, with
no check index used in the data arrays, because these are simple graphs
without error-bars or comparisons.

xGraph data arrays
------------------

The data input to *xGraph* can come from a file, or from data generated
directly from any compatible program.

The data is stored in a cell array :math:`data` with structure:

.. math:: data\{s\}\{n\}(\ell,\mathbf{j},c)

Each member of the outer cell array *data{s}* defines a number of
related sets of graphical data, all described by common parameters
*input{s}*. Comparisons and errors are plotted if there are errors and
comparison data in the input, indexed by *c*. This generates comparison
plots, as well as error totals and :math:`\chi`- squared error estimate
when there are statistical variances available.

An individual member of *data{s}{n}* is a multidimensional array, called
a *graph* in the xSPDE User’s guide. For each *graph*, multiple
different plots with different dimensionality can be obtained from the
dataset *data{s}{n}*, either through projections and slices or by
generating additional data defined with graphics functions. Either or
both alternatives are available.

Note that:

-  If a sequence has one member, the outer cell array can be omitted.

-  In this simplified case, if there is only one *graph* array, the
   inner cell array can be omitted.

The graphics data for a single dataset is held in a multidimensional
real array, where:

-  :math:`\ell` is the index for lines in the graph. Even for one line,
   the first dimension is retained.

-  :math:`\mathbf{j}=j_{1},\ldots j_{d}` is the array index in each
   dimension, where :math:`d\ge1`.

-  Averages in momentum space have the momentum origin as the central
   index.

-  If integrals or spatial averages are used, the corresponding
   dimension has one index :math:`j_{d}=1`.

-  With probabilities, extra dimensions are added to :math:`\mathbf{j}`
   to store the bin indices.

-  *c* indexes error-checks and comparisons. If not present, omit
   *p.errors* and the last dimension.

-  If :math:`c>p.errors`, the extra fields are comparison inputs, where
   :math:`p.errors` is the largest data index.

When the optional comparison fields are used, an input parameter
:math:`errors` is required to indicate the maximum error index, to
distinguish data from comparisons. Parameter structures from xSIM have
:math:`errors=3` set to allow for both sampling errors and
discretization errors. If this is omitted, the default is
:math:`errors=0`, which implies that there is no error or comparison
data

If :math:`errors>0`, the last index can have larger values with
:math:`c>errors`, for comparisons. The special case of :math:`errors=1`
is used if the data has no error bars, but there are comparisons in the
data. Larger indices are used to index the comparison data, which can
also have two types of errors. The largest usable last index is
:math:`errors+3`.

It is possible to directly plot the *raw* data using xGraph. One can
even combine the raw data with a graphics parameter input. But since the
raw data has no error estimates - it is raw data - one must set
:math:`p.errors=0`, since the xsim output parameters have a normal
setting of :math:`p.errors=3`. This will give a single trajectory.

However, the raw data from a simulation typically includes many
trajectories if *:math:`ensembles(1)>0`*. One must select particular
trajectory datasets from the raw cell array, to plot just one.

Input parameters and defaults
-----------------------------

A sequence of graph parameters is obtained from inputs in a cell array,
as *input = {in1, in2, ...}*. The input parameters of each simulation in
the sequence are specified in a Matlab structure. The inputs are
numbers, vectors, strings, functions and cell arrays. All metadata has
preferred values, so only changes from the preferences need to be input.
The resulting data is stored internally as a sequence of structures in a
cell array, to describe the simulation sequence.

The graphics parameters are also stored in the cell array *input* as a
sequence of structures *p.* This only need to be input when the graphs
are generated and can be changed at a later time to alter the graphics
output. A sequence of simulations is graphed from *input*
specifications.

If there is one simulation, just one structure can be input, without the
sequence braces. The standard way to input each parameter value is:

.. math:: p.label=parameter

The standard way to input a function handle is:

.. math:: p.label=@function

The inputs are scalar or vector parameters or function handles.
Quantities relating to graphed averages are cell arrays, indexed by the
graph number. The available inputs, with their default values in
brackets, are given below.

Simulation metadata, including default values that were used in a
particular simulation, can be included in the input data files. This is
done in both the *.mat* and the *.h5* output files generated by xSIM, so
the entire graphics input can be reconstructed or changed.

Parameters can be numbers, vectors, strings or cell arrays. Conventions
that are used are that:

-  All input parameters have default values

-  Vector inputs of numbers are enclosed in square brackets, *[...]*.

-  Cell arrays of strings, functions or vectors are enclosed in curly
   brackets.

-  Vector or cell array inputs with only one member don’t require
   brackets.

-  Incomplete parameter inputs are completed with the last used default
   value.

-  Function definitions can be handles pointing elsewhere, or defined
   inline.

If any inputs are omitted, there are default values which are set by the
internal function *xgpreferences*. The defaults can be changed by
editing *xgpreferences*.

In the following descriptions, *graphs* is the total number of graphed
variables of all types. The space coordinate, image, image-type and
transverse data can be omitted if there is no spatial lattice, that is,
if the dimension variable is set to one.

For uniformity, the graphics parameters that reference an individual
data object are cell arrays. These are indexed over the graph number
using braces *{}*. If a different type of input is used, like a scalar
or matrix, xSPDE will attempt to convert the type to a cell array.

Axis labels are cell arrays, indexed over dimension. The graph number
used to index these cell arrays refers to the data object. In each case
there can be multiple generated plots, depending on the graphics input.

Cascaded plots
--------------

The xGraph function generates a default range of graphs, but this can be
modified to suit the user. In the simplest case of one dimension, one
graph dataset will generate a single plot. For higher dimensions, a
cascade of plots is generated to allow visualization, starting from 3D
movies, then 3D static plots and finally 2D slices. These can also be
user modified.

Note that for all probabilities, the plot dimension is increased by the
bin range dimensionality.

Plot dimensions
~~~~~~~~~~~~~~~

The *pdimension* input sets the maximum plotted dimensions. For example,
:math:`pdimension\{1\}=1` means that only plots vs :math:`r_{1}` are
output for the first function plotted. Default values are used for the
non-plotted dimensions, unless there are axes specified, as indicated
below.

The graphs cascade down from higher to lower dimensions, generating
different types of graphs. Each type of graph is generated once for each
function index.

Plot axes
~~~~~~~~~

The graphics axes that are used for plotting and the points plotted are
defined using the optional *axes* input parameters, where
:math:`axes\{n\}` indicates the *n*-th specified graph or set of
generated graph data.

If there are no *axes* inputs, or the *axes* inputs are zero - for
example, :math:`axes\{1\}=\{0,0,0\}` - only the lowest dimensions are
plotted, up to *3*. If either the data or *axes* inputs project one
point in a given dimension, - for example,
:math:`axes\{1\}=\{0,31,-1,0\}`, this dimension is suppressed in the
plots, which reduces the effective dimension of the data - in this case
to two dimensions.

Examples:

-  :math:`axes\{1\}=\{0\}` - For function 1, plot all the first
   dimensional points; higher dimensions get defaults.

-  :math:`axes\{2\}=\{-2,0\}` - For function 2, plot the maximum value
   of :math:`r_{1}` (the default) and all higher-dimensional x-points.

-  :math:`axes\{3\}=\{1:4:51,32,64\}` - For function 3, plot every 4-th
   :math:`x_{1}` point at :math:`x_{2}` point 32, :math:`x_{3}` point 64

-  :math:`axes\{4\}=\{0,2:4:48,0\}` - For function 4, plot every
   :math:`x_{1}` point , every 4-th :math:`x_{2}` point, and all
   :math:`x_{3}`-points.

Points labelled :math:`-1` indicates a default ‘typical’ point, which is
the midpoint. If one uses :math:`-2`, this is the last point.

Lower dimensions are replaced by corresponding higher dimensions if
there are *dimensions* or *axes* that are suppressed. Slices can be
taken at any desired point, not just the midpoint. The notation of
:math:`axes\{1\}=\{6:3:81\}`, is used to modify the starting, interval,
and finishing points for complete control on the plot points.

The graphics results depend on the resulting **effective** dimension,
which is equal to the actual input data dimension unless there is an
*axes* suppression, described above. Since the plot has to include a
data axis, the plot itself will usually have an extra data axis.

One can plot only three axes directly using standard graphics tools. The
strategy to deal with the higher effective dimensionality is as follows.
For simplicity, “time” is used to label the first effective dimension,
although in fact any first dimension is possible:

*dimensions = 1*
   For one lattice dimension, a 2D plot of observable *vs t* is plotted,
   with data at each lattice point in time. Exact results, error bars
   and sampling error bounds are included if available.

*dimensions = 2*
   For two lattice dimensions, a 3D image of observable *vs x,t* is
   plotted. A movie of distinct 2D graphic plots is also possible.
   Otherwise, a slice through :math:`x=0` is used tp reduce the lattice
   dimension to :math:`1`.

*dimensions = 3*
   For three lattice dimensions, if :math:`images>1`, a movie of
   distinct 3D graphic images of observables are plotted as
   :math:`images` slices versus the first plot dimension. Otherwise, a
   slice through the chosen point, is used at the highest dimension to
   reduce the lattice dimension to :math:`2`.

*dimensions = 4,5..*
   For higher lattice dimensions, a slice through a chosen point, or the
   default midpoint is used to reduce the lattice dimension to
   :math:`3`.

As explained above, in addition to graphs versus :math:`x_{1}` the
**xGraph** function can generate *images* (3D) and *transverse* (2D)
plots at specified points, up to a maximum given by the number of points
specified. The number of these can be individually specified for each
graph number. The images available are specified as
*imagetype*\ :math:`=1,\ldots4`, giving:

#. 3D perspective plots (Matlab *surf* - the default)

#. 2D filled color plots (Matlab *contourf* )

#. contour plots (Matlab *contour* )

#. pseudo-color plots (Matlab *pcolor* )

Error bars, sampling errors and multiple lines for comparisons are only
graphed for 2D plots. Error-bars are not plotted when they are below a
user-specified size, with a default of :math:`1\%` of the maximum range,
to improve graphics quality. Higher dimensional graphs do not output
error-bars, but they are still recorded in the data files.

Probabilities and parametric plots
----------------------------------

Probability data can be input and plotted like any other data. It is
typically generated from simulation programs using the :math:`binranges`
data for binning. It is plotted like any other graph, with any
dimension, except that the total dimension is extended by the number of
variables or lines in the *observe* function.

Chi-squared plots
~~~~~~~~~~~~~~~~~

In addition the program can make a :math:`\chi^{2}` plot, which is a
plot of the :math:`\chi^{2}` comparison with a comparison probability
density against space and/or time. This allows a test of the simulated
data against a known target probability distribution, provided that the
following input data conditions are satisfied:

-  The input data dimension exceeds the p.\ *dimensions* parameter,

-  The switch p.\ *chisqplot* is set to :math:`1`\ or 2, and

-  The input data includes comparison function data.

The :math:`\chi^{2}` plots, depending on :math:`p.chisqplot` are:

#. a plot of :math:`\chi^{2}` and :math:`k`, where :math:`k` is the
   number of valid data points,

#. a plot of :math:`\sqrt{2\chi^{2}}` and :math:`\sqrt{2k-1}`, which
   should have a unit variance.

Here, for one point in space and time, with :math:`m` bins,
:math:`N_{j}` counts per bin and :math:`E_{j}` expected counts:

.. math:: \chi^{2}=\sum_{j=1}^{m}\frac{\left(N_{j}-E_{j}\right)^{2}}{E_{j}}.

The number :math:`k` is the number of valid counts, with
:math:`N_{j},E_{j}>mincount`. This is partly determined from the
requirement that the probability count data per bin is greater than the
:math:`p.mincount` parameter. The default is set to give a number of
samples :math:`>10`. The program prints a summary that sums over of all
the :math:`\chi^{2}` data.

The :math:`p.scale\{n\}` parameter gives the number of counts per bin at
unit probability density. This is needed to set the scale of the
:math:`\chi^{2}` results, ie, :math:`N_{j}=scale\{n\}\times p_{j}`,
where :math:`p_{j}` is the probability density that is compared and
plotted in the simulation data. Note that a uniform bin size is assumed
here, to give a uniform scaling.

Comparisons with variances
~~~~~~~~~~~~~~~~~~~~~~~~~~

It can be useful to compare two probability distributions with different
variances. For one point in space and time, with :math:`m` bins,
:math:`p_{j}` probability density and :math:`e_{j}` expected probability
density,

.. math:: \chi^{2}=\sum_{j=1}^{m}\frac{\left(p_{j}-e_{j}\right)^{2}}{\sigma_{j}^{2}+\sigma_{e,j}^{2}}.

In this case, :math:`\sigma_{j}^{2}` and :math:`\sigma_{e,j}^{2}` are
the sampling errors in the simulation data and comparison data, so that
built-in error fields in the data are used to work out the
:math:`\chi^{2}` results. This option is chosen if
:math:`p.scale\{n\}=0`, and the cutoff for the data is then specified so
that :math:`p_{j},e_{j}>p.cutoffs\{n\}`. This only has a
:math:`\chi^{2}` distribution if points are independent.

Maximum likelihood
~~~~~~~~~~~~~~~~~~

It is also possible to plot the :math:`G^{2}` or maximum likelihood plot
of the data, which is an alternative means to compare distributions,
where

.. math:: G^{2}=2\sum_{j=1}^{m}N_{j}\ln\left(N_{j}/E_{j}\right).

The expected values :math:`E_{j}` are automatically scaled so that
:math:`\sum N_{j}=\sum E_{j},`\ with the same minimum count cutoff that
is used for the :math:`\chi^{2}` data. The result is similar to the
:math:`\chi^{2}` results. It is obtained if p.\ *gsqplot* is set to
:math:`1` or 2 and requires for the input that :math:`p.scale\{n\}>0.`
It is sometimes regarded as a preferred method for comparisons.

Parametric plots
~~~~~~~~~~~~~~~~

Any input dataset can be converted to a parametric plot, where a second
data input is plotted along the horizontal axis instead of the time
coordinate. It is also possible to substitute a second data input for
the x-axis data if a parametric plot in space is required instead. This
allows visualization of how one type of data changes as a function of a
second type of data input.

The two datasets that are plotted must have the same number of lines,
that is, the first index range should be the same, in order that
multiple lines can be compared. This is achieved where required using
the *p.scatters* input in the simulation code. The details of the
parametric plot are specified using the input: *

.. math:: p.parametric\{n\}=[n1,p2]

*

Here :math:`n` is the graph number which is plotted, and must correspond
to an input dataset. The number :math:`n1` is the graph number of the
observable that is plotted on the horizontal axis, ignoring functional
transformations. The second number is the axis number where the
parametric value is substituted, which can be the time (axis 1) or the
x-coordinate (axis 2), if present.

In all cases the vertical axis is used to plot the original data. The
specified horizontal axis is used for the parametric variable. Only
vertical error-bars are available.

.. _parameter-reference-1:

Parameter reference
-------------------

*axes{n}*
~~~~~~~~~

Default:
   *{0,0,0,..}*

Gives the axis points plotted for the :math:`n`-th plotted function, in
each dimension. Each entry value is a vector range for a particular plot
and dimension. Thus, *p = 5* gives the fifth point only, and a vector
input *p = 1:4:41* plots every fourth point. Single points generate
graphics projections, allowing the other dimensions to be plotted. Zero
or negative values are shorthand. For example, *p = -1* generates a
default point at the midpoint, *p = -2* the endpoint, and *p = 0* is the
default value that gives the vector for the every axis point. For each
graph type, i.e. *n=1,..graphs* the axes can be individually specified
in each dimension, *d=1,..dimension*\ s. If more than three axes are
specified to be vectors, only the first three are used, and others are
set to default values in the plots.

Example:
   *p.axes{4} = {1:2:10,0,0,-1}*

*diffplot{n}*
~~~~~~~~~~~~~

Default:
   *0*

Differences are plotted as a comparison dashed line on :math:`2D` plots
as a default. Otherwise, a separate difference plot is obtained which is
unnormalized (*diffplot = 1)*, or normalized (*diffplot = 2)* by the
total RMS errors. If *diffplot = 3*, the comparison data is plotted
directly as an additional graph.

Example:
   *p.diffplot{3} = 2*

*errors*
~~~~~~~~

Default:
   *0*

Indicates if the last index in the graphics input data arrays is used
for error-bars and/or comparisons. Should be set to zero if there is no
error or comparison data. If non-zero, this will give the highest last
index used for errors. The standard *xsim* output sets
*:math:`p.errors=3`* automatically. As a special case,
*:math:`p.errors=1`* is used to indicate that there is comparison data
but no error data.

If *:math:`p.errors>0`* , the data indexed up to *p.errors* gives the
data, then a maximum of two types of error bars. Up to three further
index values, up to *:math:`p.errors+3`,* are available to index all
comparison data and its error fields. The maximum last index value used
is :math:`6`.

Example:
   *p.errors = 2*

*esample{n}*
~~~~~~~~~~~~

Default:
   *1*

This sets the type and size of sampling errors that are plotted. If
*esample = 0*, no sampling error lines are plotted, just the mean. If
:math:`esample=-n`, :math:`\pm n\sigma` sampling errors are included in
the error-bars. If :math:`esample=n`, separate upper and lower
:math:`\pm n\sigma` sampling error lines are plotted. In both cases, the
magnitude of esample sets the number of standard deviations used.

Example:
   *p.esample{3} = -1*

*font{n}*
~~~~~~~~~

Default:
   *18*

This sets the default font sizes for the graph labels, indexed by graph.
This can be changed per graph.

Example:
   *p.font{4}=18*

*functions*
~~~~~~~~~~~

Default:
   number of functional transformations

This gives the maximum number of output graph functions and is available
to restrict graphical output. The default is the length of the cell
array of input data. Normally, the default will be used.

Example:
   *p.functions = 10*

*glabels{n}*
~~~~~~~~~~~~

Default:
   *xlabels* or *klabels*

Graph-dependent labels for the independent variable labels. This is a
nested cell array with first dimension of *graphs* and second dimension
of *dimension*\ s. This is used to replace the global values of
*xlabels* or *klabels* if the axis labels change from graph to graph,
for example, if the coordinates have a functional transform. These can
be set for an individual coordinate on one graph if needed.

Example:
   *p.glabels{4}{2} = ’x^2’*

*graphs*
~~~~~~~~

Default:
   observables to plot

This gives the observables to plot. The default is a vector of indices
from one to the length of the cell array of observe functions. Normally
not initialized, as the default is used. Mostly used to reduce graphical
output on a long file.

Example:
   *p.graphs = 10*

*gtransforms{n}*
~~~~~~~~~~~~~~~~

Default:
   [0,0,...]

This switch specifies the Fourier transformed graphs and axes for
graphics labeling. Automatically equal to *ftransforms* if from an
earlier xSIM input, but can be changed. If altered for a given graph,
all the axis Fourier switches should be reset. This is ignored if there
is no *dimensions* setting to indicate space dimensions.

Example:
   *p.gtransforms{1} = [0,0,1]*

*headers{n}*
~~~~~~~~~~~~

Default:
   *”*

This is a string variable giving the graph headers for each type of
function plotted. The default value is an empty string. Otherwise, the
header string that is input is used. Either is combined with the
simulation name and a graph number to identify the graph. This is used
to include simulation headers to identify graphs in simulation outputs.
Graph headers may not be needed in a final published result. For this,
either edit the graph, or use a space to make plot headers blank:
*p.headers{n} = ’ ’*, or *p.name = ’ ’* .

Example:
   *p.headers{n} = ’my_graph_header’*

*images{n}*
~~~~~~~~~~~

Default:
   *0*

This is the number of 3D, transverse o-x-y images plotted as discrete
time slices. Only valid if the input data dimension is greater than 2.
If present, the coordinates not plotted are set to their central value
when plotting the transverse images. This input should have a value from
zero up to a maximum value of the number of plotted points. It has a
vector length equal to *graphs.*

Example:
   *p.images{4} = 5*

*imagetype{n}*
~~~~~~~~~~~~~~

Default:
   *1*

This is the type of transverse o-x-y movie images plotted. It has a
vector length equal to *graphs*.

-  *imagetype =* *1* gives a perspective surface plot

-  *imagetype =* *2*, gives a 2D plot with colors

-  *imagetype =* 3 gives a contour plot with 10 equally spaced contours

-  *imagetype =* 4 gives a pseudo-color map

Example:
   *p.imagetype{n} = 1, 2, 3, 4*

*klabels*
~~~~~~~~~

Default:
   *{’\\omega’, ’k_x’, ’k_y’, ’k_z’}“ or “{’k_1’, ’k_2’, ’k_3’,
   ’k_4’,...}*

Labels for the graph axis Fourier transform labels, vector length of
*dimension*\ s. The numerical labeling default is used when the
“\ *p.numberaxis*\ “ option is set. Note, these are typeset in Latex
mathematics mode! When changing from the default values, all the
required new labels must be set.

Example:
   *p.klabels= {’\\Omega’, ’K_x’, ’K_y’,}*

*legends{n}*
~~~~~~~~~~~~

Default:
   *{”,”}*

Graph-dependent legends, specified as a nested cell array of strings for
each line.

Example:
   *p.legends{n} = {labels(1), ..., labels(lines)}*

*limits{n}*
~~~~~~~~~~~

Default:
   *{0,0,0,0; ...}*

Graph-dependent limits specified as a cell array with dimension
*graphs*. Each entry is a cell array of graph limits indexed by the
dimension, starting from :math:`d=1` for the time dimension. The limits
are vectors, indexed as 1,2 for the lower and upper plot limits. This is
useful if the limits required change from graph to graph. If an
automatic limit is required for either the upper or lower limit, it is
set to *inf.*

An invalid, scalar or empty limit vector, like [0,0] or :math:`0` or []
is ignored, and an automatic graph limit is used.

Example:
   *p.limits{n} = {[t1,t2],[x1,x2],[y1,y2] ...,}*

*linestyle{n}*
~~~~~~~~~~~~~~

Default:
   *{’-k’,’--k’,’:k’,’-.k’,’-ok’,’--ok’,’:ok’,’-.ok’,’-+k’,’--+k’}*

Line types for each line in every two-dimensional graph plotted. If a
given line on a two-dimensional line is to be removed completely, set
the relevant line-style to zero. For example, to remove the first line
from graph 3, set p.linestyle{3} ={0}. This is useful when generating
and changing graphics output from a saved data file. The linestyle uses
Matlab terminology. It allows setting the line pattern, marker symbols
and color for every line. The default lines are black (*’k’*), but any
other color can be used instead.

The specifiers must be chosen from the list below, eg, ’-ok’, although
the marker can be omitted if not required.

-  Line patterns: ’-’ (solid), ’–’ (dashed), ’:’ (dotted) ,’-.’
   (dash-dot)

-  Marker symbols: ’+’,’o’,’\*’,’.’,’x’,’s’,’d’,’^’,’v’,’>’,’<’,’p’

-  Colors: ’r’,’g’,’b’,’c’,’m’,’y’,’k’,’w’

Example:
   *p.linestyle{4} = {’-k’,’--ok’,’:g’,’-.b’,}*

*linewidth{n}*
~~~~~~~~~~~~~~

Default:
   0.5

Line width for plotted lines in two-dimensional graphs. For example, to
make the lines wider in graph 3, set p.linewidth{3} =1. This is useful
for changing graphics output appearance if the default lines are too
thin.

Example:
   *p.linewidth{n} = 1*

*minbar{n}*
~~~~~~~~~~~

Default:
   *{0.01, ...}*

This is the minimum relative error-bar that is plotted. Set to a large
value to suppress unwanted error-bars, although its best not to ignore
the error-bar information! This can be changed per graph.

Example:
   *p.minbar{n} = 0*

.. _name-1:

*name*
~~~~~~

Default:
   ”

Name used to label simulation graphs, usually corresponding to the
equation or problem solved. This can be removed from individual graphs
by using *headers{n}* equal to a single blank space. The default is a
null string. To remove all headers globally, set *name* equal to a
single blank space: *name = ’ ’.*

Example:
   *p.name = ’Wiener process simulation’*

*olabels{n}*
~~~~~~~~~~~~

Default:
   *’a’*

Cell array of labels for the graph axis observables and functions. These
are text labels that are used on the graph axes. The default value is
*’a_1*\ ’ if the default observable is used, otherwise it is blank. This
is overwritten by any subsequent label input when the graphics program
is run:

Example:
   *p.olabels{4} = ’v’*

*parametric{n}*
~~~~~~~~~~~~~~~

Default:
   *[0,0]*

Cell array that defines parametric plots, for each graph number. The
first number is the graph number of the alternative observable plotted
on the horizontal axis. The second number is the axis number where the
parametric value is substituted, which can be the time (axis 1) or the
x-coordinate (axis 2), if present.

If both are zero, the plot against an independent space-time coordinate
is calculated as usual. If nonzero, a parametric plot is made for
two-dimensional plots. In all cases the vertical axis is used to plot
the original data. The specified horizontal axis is used for the
parametric variable. Only vertical error-bars are available. Can be
usefully combined with *scatters{n}* to plot individual trajectories,
but the number of scatters should be the same in each of the two graphs
that are parametrically plotted against each other.

Example:
   *p.parametric{n} = [p1,p2] > = 0*

*pdimension{n}*
~~~~~~~~~~~~~~~

Default:
   *3*

This is the maximum plotted space-time dimension for each plotted
quantity. The purpose is eliminate unwanted graphs. For example, it is
useful to reduce the maximum dimension when averaging in space. Higher
dimensional graphs are not needed, as the data is duplicated. Averaging
can be useful for checking conservation laws, or for averaging over
homogeneous data to reduce sampling errors. All graphs are suppressed if
it is set to zero. Any three dimensions can be chosen to be plotted,
using the *axes* parameter to suppress the unwanted data points in other
dimensions.

Example:
   *p.pdimension{4} = 2*

*saveeps*
~~~~~~~~~

Default:
   0

If set to :math:`1`, all plots are saved to the current folder as .eps
files, numbered consecutively. It is best to use the *close all* command
first to remove unwanted displayed xFIGURES, before running *xGraph*
with this option.

Example:
   *p.saveeps =1*

*savefig*
~~~~~~~~~

Default:
   0

If set to :math:`1`, all plots are saved to the current folder as .fig
files, numbered consecutively. It is best to use the *close all* command
first to remove unwanted displayed xFIGURES, before running *xGraph*
with this option.

Example:
   *p.savefig =1*

*transverse{n}*
~~~~~~~~~~~~~~~

Default:
   *0*

This is the number of 2D transverse images plotted as discrete time
slices. Only valid if *dimensions* is greater than 2. If present, the
:math:`y,z`-coordinates are set to their central values when plotting
transverse images. Each element can be from 0 up to the number of
plotted time-points. The cell array has a vector length equal to
*graphs*.

Example:
   *p.transverse{n}= 6*

.. _verbose-1:

*verbose*
~~~~~~~~~

Default:
   0

Print flag for output information while running xGraph. Print options
are:

-  Minimal if *verbose = -1*: Prints just the start-up time and hard
   error messages

-  Brief if *verbose = 0*: Additionally prints the final, total
   chi-squared errors where present

-  Informative if *verbose = 1*: Also prints the graph progress
   indicators

-  Full if *verbose = 2*: Prints everything including the internal
   parameter structure data.

In summary, if *verbose = 0*, most output is suppressed except the final
data, *verbose = 1* displays a progress report, and *verbose = 2*
additionally generates a readable summary of the graphics parameter
input.

Example:
   *p.verbose = 0*

*xlabels*
~~~~~~~~~

Default:
   *{’t’, ’x’, ’y’, ’z’}* or {*’x_1’, ’x_2’, ’x_3’, ’x_4’*,...}

Global labels for the independent variable labels, vector length equal
to *dimension*\ s. The numerical labeling default is used when the
*numberaxis* option is true. These are typeset in Latex mathematics
mode. When changing from the default values, all the required new labels
must be set.

Example:
   *p.xlabels = {’tau’}*

User function reference
-----------------------

It is possible to simply run *xGraph* as is, without much intervention.
However, there are customization options, including user defined
functions. These are as follows:

*gfunction{n} (d,p)*
~~~~~~~~~~~~~~~~~~~~

This is a cell array of graphics function handles. Use when a graph is
needed that is a functional transformation of the observed averages. The
default value generates the *n-th* graph *data* array directly from the
*n-th* input *data*. The input is the data cell array for all the graphs
in the current sequence number with their graph parameters *x*, and the
output is the *n-th* data array that is plotted.

An arbitrary number of functions of these observables can be plotted,
including vector observables. The input to graphics functions is the
observed data averages or functions of averages in a given sequence,
each stored in a cell array :math:`d\{n\}(\ell,\mathbf{j},c)`. If there
are more graphics functions than input data cells, this generate
additional data for plotting.

*xfunctions{n} {nd} (ax,p)*
~~~~~~~~~~~~~~~~~~~~~~~~~~~

This is a nested cell array of axis transformations. Use when a graph is
needed with an axis that is a function of the original axes. The input
is the original axis coordinates, and the output is the new coordinate
set. The default value generates the input axes. Called as
*xfunctions{n}{nd}(ax,p)* for the *n*-th graph and axis direction *dir*,
where *ax* is a vector of coordinates for that axis.There is one
graphics function for each separate graph dimension or axis. The default
value is the coordinate vector :math:`xk\{nd\}` stored in the input
parameter structure p, or else the relevant index if *xk{nd}* is
omitted.

.. |image| image:: xQSim_uni_sq_fig
   :width: 50.0%
.. |image1| image:: xQSim_uni_sq_diff_fig
   :width: 50.0%
.. |image2| image:: xQSim_therm_fig
   :width: 50.0%
.. |image3| image:: xQSim_therm_diff_fig
   :width: 50.0%
.. |image4| image:: xQSim_non_uni_sq_2D_fig
   :width: 50.0%
.. |image5| image:: xQSim_non_uni_sq_2D_diff_fig
   :width: 50.0%
.. |image6| image:: xQSim_non_uni_sq_4D_fig
   :width: 50.0%
.. |image7| image:: xQSim_non_uni_sq_4D_diff_fig
   :width: 50.0%
.. |image8| image:: xQSim_non_uni_th_+P_fig
   :width: 50.0%
.. |image9| image:: xQSim_non_uni_th_W_fig
.. |image10| image:: xQSim_non_uni_th_Q_fig
   :width: 50.0%
.. |image11| image:: xQSim_exp_FO_fig
   :width: 50.0%
.. |image12| image:: xQSim_exp_SO_fig
   :width: 50.0%
.. |image13| image:: xQSim_exp_rand_p1
   :width: 50.0%
.. |image14| image:: xQSim_exp_rand_p2
   :width: 50.0%
.. |image15| image:: xGraphfig1
   :width: 50.0%
.. |image16| image:: xGraphfig2
   :width: 50.0%
